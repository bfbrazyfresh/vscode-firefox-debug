<!doctype html>
<html lang="de">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta name="viewport" content="width=680">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Linkvertise - Earn Money with FRESH Links | Monetization done FRESH</title>
<link rel="icon" type="image/x-icon" href="favicon.ico">
<link rel="stylesheet" href="bootstrap/4.0.0/css/bootstrap.min.css" >
<link rel="stylesheet" href="assets/linkvertise/vendor/fontawesome/css/font-awesome.min.css" />
<link href="//fonts.googleapis.com/css?family=Raleway:300,400,500,600,700|Poppins:400,700" rel="stylesheet">
<link href="michalsnik/aos/2.1.1/dist/aos.css" rel="stylesheet">
<link rel="stylesheet" href="assets/vendor/bootstrap-sweetalerts/sweetalert.css">
<link rel="stylesheet" href="1.10.18/css/dataTables.bootstrap4.min.css">
<link rel="stylesheet" href="assets/linkvertise/vendor/switchery/switchery.min.css" />
<script src="ajax/libs/iframe-resizer/4.2.10/iframeResizer.min.js"></script>
<script src="ajax/libs/iframe-resizer/4.2.10/iframeResizer.contentWindow.min.js"></script>
<link rel="apple-touch-icon" sizes="57x57" href="apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192" href="android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<link rel="manifest" href="manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">
<script type="text/javascript">
        window.smartlook||(function(d) {
            var o=smartlook=function(){ o.api.push(arguments)},h=d.getElementsByTagName('head')[0];
            var c=d.createElement('script');o.api=new Array();c.async=true;c.type='text/javascript';
            c.charset='utf-8';c.src='recorder.js';h.appendChild(c);
        })(document);
        smartlook('init', 'bccf7892328cefde1026d1a40ac03e367762624b');
    </script>
<link rel="stylesheet" href="assets/linkvertise/style.css" />
<script src="https://www.google.com/recaptcha/api.js" async defer></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=AW-963309080"></script>
<script>
        window.dataLayer = window.dataLayer || [];
        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());
        gtag('config', 'AW-963309080');
    </script>
<link href="dropzone_5.9.3/dist/dropzone.css" rel="stylesheet" />
<link href="cropperjs/dist/cropper.css" rel="stylesheet" />
<script src="dropzone_5.9.3/dist/dropzone.js"></script>
<script src="cropperjs.js"></script>
<style>
        .dz-progress {
            display: none !important;
        }
        .dz-size {
            display: none !important;
        }
        .dz-filename {
            display: none !important;
        }
        .dropzone .dz-preview:hover .dz-image img {
            filter: unset !important;
            transform: none !important;
        }
    </style>
<script>
        Dropzone.autoDiscover = false;
    </script>
</head>
<body>
<div class="header">
<div class="top-bar">
<div class="container">
<div class="float-left">
<ul class="social">
<li class="d-none d-xl-inline-block">
<a href="https://twitter.com/Linkvertise" target="_blank"><i class="fa fa-twitter"></i></a>
</li>
<li class="d-none d-xl-inline-block">
<a href="https://www.youtube.com/channel/UCCq5_toZNT2QYNmHjHXrHbg" target="_blank"><i class="fa fa-youtube-play"></i></a>
</li>
<li class="d-none d-xl-inline-block">
<a href="https://blog.linkvertise.com/en" target="_blank"><i class="fa fa-newspaper-o"></i></a>
</li>
<li class="d-lg-none">
<a href="" data-toggle="sidebar"><i class="fa fa-bars"></i></a>
</li>
</ul>
</div>
<div class="float-right">
<ul class="navigation">
<li>
<a href="de.html">
 Deutsch
</a>
</li>
<li>
<a href="" data-toggle="modal" data-target="#modal_login">Log In</a>
</li>
<li class="featured">
<a href="" data-toggle="modal" data-target="#modal_register"><i class="fa fa-fw fa-user"></i> Register</a>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="page">
<div class="campaign">
<div class="container">
<div class="campaign-header">
Earn money. Online. Now.
<div class="campaign-subheading">
Share links and earn money on every visitor who clicks on your link -
<a href="" data-target="#modal_about" data-toggle="modal">
Learn More</a></div>
<div class="row d-none d-md-block">
<div class="col-md-6 offset-md-3">
<div class="campaign-input">
<div class="form-group">
<div class="input-group">
<input class="form-control" id="campaign-input-text" name="" placeholder="" value="" type="text">
<span class="input-group-append">
<a href="" data-toggle="modal" data-target="#modal_register" class="btn btn-success">Make money now!</a>
</span>
</div>
</div>
</div>
</div>
</div>
<div class="d-md-none">
<div class="container">
<div class="campaign-input">
<div class="mb-3">
<input class="form-control" id="campaign-input-text-sm" name="" placeholder="" value="" type="text">
</div>
<div class="text-center">
<a href="" data-toggle="modal" Safxdata-target="#modal_register" class="btn btn-success">Make money now!</a>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="campaign-background"></div>
</div>
<div class="features" data-aos="fade-up" data-aos-offset="300">
<div class="container">
<div class="row p-0">
<div class="col-md-4 p-0">
<div class="feature">
<div class="icon-wrapper bg-success">
<i class="fa fa-dollar animate-slim-spin"></i>
</div>
<h1 class="text-left">Highest payout rates</h1>
<p class="text-justify">
Earn up to 70 $ per 1000 views! - Linkvertise is the best paying link shortening site in German-speaking countries! We do not use popups or annoying layers and still offer top pay!
</p>
</div>
</div>
<div class="col-md-4 p-0">
<div class="feature">
<div class="icon-wrapper bg-danger">
<i class="fa fa-th-large animate-pulse" style="padding-top: 2px; display: inline-block;"></i>
</div>
<h1>Easy administration</h1>
<p class="text-justify">
With our optimized dashboard you always have the perfect overview of your earnings. See exactly how our shortened links perform through our stats!
</p>
</div>
</div>
<div class="col-md-4 p-0">
<div class="feature last">
<div class="icon-wrapper bg-primary">
<i class="fa fa-refresh fa-spin"></i>
</div>
<h1>Daily payments</h1>
<p class="text-justify">
Receive daily payments via bank transfer, Paysafecard or Amazon coupon for a minimum of 10 $!
</p>
</div>
</div>
</div>
</div>
</div>
<div class="sumup">
<div class="container">
<div class="row">
<div class="col-md-6">
<img src="assets/linkvertise/img/sumup.png" data-aos="fade-up" data-aos-offset="300" alt="" />
</div>
<div class="col-md-6" data-aos="fade-up" data-aos-offset="300">
<h2>Make money with Linkvertise without effort!</h2>
<p>On our website you can easily & quickly short links and earn money. Register today and test us and our tools.</p>
<ul class="list-unstyled">
<li><i class="fa fa-check fa-fw"></i> Automatic monthly payments</li>
<li><i class="fa fa-check fa-fw"></i> Clear statistics</li>
<li><i class="fa fa-check fa-fw"></i> High payouts</li>
<li><i class="fa fa-check fa-fw"></i> High user friendliness</li>
</ul>
<button data-toggle="modal" data-target="#modal_register" class="btn">Make money now!</button>
</div>
</div>
</div>
</div>
<div class="about" data-aos="fade-up" data-aos-offset="300">
<div class="container">
<h2 class="heading text-center">What is Linkvertise?</h2>
<div class="row">
<div class="col-xs-12 col-md-6 offset-md-3">
<div class="embed-responsive embed-responsive-16by9">
<iframe class="embed-responsive-item" src="https://player.vimeo.com/video/284273940?title=0&byline=0&portrait=0" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
</div>
</div>
</div>
</div>
</div>
<hr />
<div class="testimonials" data-aos="fade-up" data-aos-offset="300">
<div class="container">
<h2 class="heading">Customer reviews</h2>
<div class="row">
<div class="col-md-4">
<h4>Sebastian R.</h4>
<p class="position">YOUTUBER</p>
<p>
I mainly use Linkvertise to monetize downloads in my video description. The results are great. I come to 9.70 $ per 1000 views - very good work, guys :) I like the passive income!
</p>
<div class="d-md-none">
<hr />
<div class="text-center text-warning">
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
</div>
</div>
</div>
<div class="col-md-4">
<h4>Erik A.</h4>
<p class="position">FORUM USER</p>
<p>
I've been using Linkvertise for a long time to make money with my links posted on forums or blogs. It is a really good service and, above all, better to use than the conventional websites, because you can, for example, change links afterwards, without having to change the generated link.
</p>
<div class="d-md-none">
<hr />
<div class="text-center text-warning">
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
</div>
</div>
</div>
<div class="col-md-4">
<h4>Jana M.</h4>
<p class="position">TWITTER INFLUENCER</p>
<p>
At first I was a bit skeptical, but now I know that you can trust on the payouts of Linkvertise in any case. I really like the regular and guaranteed payouts and therefore I will continue to use this website in the future.
</p>
<div class="d-md-none">
<hr />
<div class="text-center text-warning">
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star-half-o"></i>
</div>
</div>
</div>
</div>
<div class="row d-none d-md-flex">
<div class="col-md-4">
<hr />
<div class="text-center text-warning">
<i class="fa fa-star"></i>
</div>
<div class="col-md-4">
<hr />
<div class="text-center text-warning">
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
</div>
</div>
<div class="col-md-4">
<hr />
<div class="text-center text-warning">
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
 <i class="fa fa-star"></i>
</div>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star"></i>
<i class="fa fa-star-half-o"></i>
</div>
</div>
</div>
</div>
</div>
<div class="footer-payout">
<div class="payment-item-container">
<div class="payment-item-wrapper">
<img class="payment-image-light" src="assets/img/ach.png" alt="" />
<p class="payment-text">ACH</p>
</div>
<div class="payment-item-wrapper">
<img class="payment-image-light" src="assets/img/wiretransfer.png" alt="" />
<p class="payment-text">Wire-Transfer</p>
</div>
<div class="payment-item-wrapper">
<img class="payment-image-light" src="assets/img/paypal.png" alt="" />
<p class="payment-text">Paypal</p>
</div>
<div class="payment-item-wrapper">
<img class="payment-image-light" src="assets/img/echeck.png" alt="" />
<p class="payment-text">eCheck/Bank Transfer</p>
</div>
</div>
</div>
</div>
<div class="youtube-wrapper">
<a href="https://blog.linkvertise.com/en/publisher/linkvertise-links-are-youtube-policies-compliant/" target="_blank"><img src="assets/linkvertise/img/youtube_en.png" alt=""></a>
</div>
<div class="modal fade" id="modal_about">
<div class="modal-dialog modal-lg">
<div class="modal-content">
<div class="modal-body">
<button type="button" class="close" data-dismiss="modal">&times;</button>
<h3 class="modal-header">
Was ist Linkvertise?
</h3>
<div class="embed-responsive embed-responsive-16by9">
<iframe class="embed-responsive-item" src="https://player.vimeo.com/video/284273940?title=0&byline=0&portrait=0" width="640" height="360" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="modals">
<div class="modal fade" id="modal_login">
<div class="modal-dialog modal-md">
<div class="modal-content">
<div class="modal-body">
<button type="button" class="close" data-dismiss="modal">&times;</button>
<div class="h3 modal-header">Login</div>
<form data-ajax="https://publisher.linkvertise.com/login">
<div class="alert-wrapper"></div>
<div class="form-group">
<label class="control-label" for="email">Email address<span class="text-danger">*</span></label>
<input class="form-control" id="email" name="email" placeholder="Email address" autocomplete="off" type="email">
</div>
<div class="form-group">
<label class="control-label" for="password">Password <span class="text-danger">*</span></label>
<input class="form-control" id="password" name="password" placeholder="Password" type="password">
</div>
<hr />
<div class="text-center">
<a href="" data-dismiss="modal" data-target="#auth__password_forgot" data-toggle="modal">Forgot password.</a>
</div>
<hr />
<div class="text-center">
<div class="g-recaptcha d-flex justify-content-center" data-sitekey="6LcEr_UUAAAAAHXt5wx-k9P_m8Z1JY-Ck9Mxrhxo">
</div>
</div>
<hr />
<div class="form-group">
<div class="row">
<div class="col-xs-12 col-md-6 offset-md-3">
<button type="submit" class="btn btn-block btn-success">Login</button>
</div>
</div>
</div>
</form>
</div>
</div>
</div>
</div>
<div class="modal fade" id="modal_register">
<div class="modal-dialog modal-md">
<div class="modal-content">
<div class="modal-body">
<button type="button" class="close" data-dismiss="modal">&times;</button>
<h3 class="modal-header">Register now and earn money.</h3>
<p class="text-center">
Here you can register yourself for free.
</p>
<hr />
<form data-ajax="https://publisher.linkvertise.com/register" id="register_form">
<div class="alert-wrapper"></div>
<div class="input-wrapper">
</div>
<div class="form-group">
<label class="control-label" for="username">Username<span class="text-danger">*</span></label>
<input class="form-control" id="username" name="username" placeholder="Username" autocomplete="off" type="text">
</div>
<div class="form-group">
<label class="control-label" for="email">Email address<span class="text-danger">*</span></label>
<input class="form-control" id="email" name="email" placeholder="Email address" autocomplete="off" type="text">
</div>
<div class="form-group">
<label class="control-label" for="password">Password <span class="text-danger">*</span></label>
<input class="form-control" id="password" name="password" placeholder="Password" type="password">
</div>
<div class="form-group">
<label class="control-label" for="password_confirmation">Confirm password <span class="text-danger">*</span></label>
<input class="form-control" id="password_confirmation" name="password_confirmation" placeholder="Confirm password" type="password">
</div>
<hr />
<div class="text-center">
<div class="form-check">
<label class="form-check-label">
<input name="agb" type="checkbox" class="form-check-input">
I accept the <a href="" data-toggle="modal" data-target="#modal_agb">Terms of service</a>,
the <a href="" data-toggle="modal" data-target="#modal_datenschutz">Data protection</a>,
the <a href="" data-toggle="modal" data-target="#modal_teilnahme">Terms of participation</a> and
the <a href="" data-toggle="modal" data-target="#modal_programm">Program guidelines</a>
</label>
</div>
</div>
<hr />
<div class="text-center">
<div class="form-check">
<label class="form-check-label">
<input name="email_access" type="checkbox" class="form-check-input">
I can accept the above mentioned email address.
</label>
</div>
</div>
<hr />
<div class="text-center">
<div class="g-recaptcha d-flex justify-content-center" data-sitekey="6LcEr_UUAAAAAHXt5wx-k9P_m8Z1JY-Ck9Mxrhxo">
</div>
</div>
<hr />
<div class="form-group">
<div class="row">
<div class="col-xs-12 col-md-6 offset-md-3">
<button type="submit" class="btn btn-block btn-success">Register now</button>
</div>
</div>
</div>
</form>
</div>
</div>
</div>
</div>
<div class="modal fade" id="modal_programm">
<div class="modal-dialog modal-lg">
<div class="modal-content">
<div class="modal-header">
<div class="float-left">
<div class="headline">
Program policies
</div>
</div>
<div class="float-right close-btn" data-dismiss="modal"><i class="fa fa-times pointer"></i></div>
</div>
<div class="modal-body">
<p>
All Linkvertise users are required to comply with the following program policies. Please read it carefully. For unauthorized violations of these policies, we reserve the right to reclassify your account at any time or disable it in the event of serious violations. If your Linkvertise account is disabled, you will no longer be allowed to join our service again. </p>
<p>
Please note that violating the policy of <u>a single link</u> can lead to action against your entire account.
</p>
<h5>Guidelines for linked Websites:</h5>
<div class="guideline d-flex">
<i class="fa fa-exclamation-triangle yellow" aria-hidden="true"></i>
<span>It is not allowed to link to pornographic or adult content.</span>
</div>
<div class="guideline d-flex">
<i class="fa fa-exclamation-triangle yellow" aria-hidden="true"></i>
<span>It is not allowed to link to violence-glorifying content, hate speech, harassment, or content related to bullying or obscenity.</span>
</div>
<div class="guideline d-flex">
<i class="fa fa-exclamation-triangle yellow" aria-hidden="true"></i>
<span>It is not allowed to link to content related to illegal drugs.</span>
</div>
<div class="guideline d-flex">
<i class="fa fa-exclamation-triangle yellow" aria-hidden="true"></i>
<span>It is not allowed to link Linkvertise links into each other ("loop traffic") or use other methods to confuse visitors. So-called "link chains" in which Linkvertise links occur more than once are also not allowed.</span>
</div>
<div class="guideline d-flex">
<i class="fa fa-exclamation-triangle yellow" aria-hidden="true"></i>
<span>It is not allowed to monetize the deep links monetized via Linkvertise via comparable service providers or otherwise to make them publicly available (see also our conditions of participation for the exclusive granting of rights to us).</span>
</div>
<div class="guideline d-flex">
<i class="fa fa-exclamation-triangle red" aria-hidden="true"></i>
<span>It is not allowed to link to copyright infringing or protected content without having the necessary rights. (especially music- or movie- downloads).</span>
</div>
<div class="guideline d-flex">
<i class="fa fa-exclamation-triangle red" aria-hidden="true"></i>
<span>It is not allowed to link to misleading or deceptive software.</span>
</div>
<div class="guideline d-flex">
<i class="fa fa-exclamation-triangle red" aria-hidden="true"></i>
<span>It is not allowed to link to malware or adware content.</span>
</div>
<h5 class="mt-4">Guidelines for Traffic Sources:</h5>
<div class="guideline d-flex">
<i class="fa fa-exclamation-triangle red" aria-hidden="true"></i>
<span>It is not allowed to click on your own Linkvertise links or use other methods to untruthfully increase the number of visitors.</span>
</div>
<div class="guideline d-flex mb-3">
<i class="fa fa-exclamation-triangle red" aria-hidden="true"></i>
<span>It is not allowed to generate visitors from the following sources: Third-party services for generating clicks, Bots, Pay-to-Click, Pay-to-Surf, Autosurf, Click-Exchange programs.</span>
</div>
<div class="guideline d-flex mt-5">
<i class="fa fa-exclamation-triangle red" aria-hidden="true"></i>
<span style="font-size: 28px; line-height: 28px">=</span>
<span>Violations of these policies will deactivate your Linkvertise account without the ability to withdraw.</span>
</div>
<div class="guideline d-flex mt-0">
<i class="fa fa-exclamation-triangle yellow" aria-hidden="true"></i>
<span style="font-size: 28px; line-height: 28px">=</span>
<span>If you violate these policies, your Linkvertise account will be reclassified and fewer advertising settings will be available.</span>
</div>
</div>
</div>
</div>
</div>
<div class="modal fade" id="modal_teilnahme">
<div class="modal-dialog modal-lg">
<div class="modal-content">
<div class="modal-body">
<button type="button" class="close" data-dismiss="modal">&times;</button>
<h3 class="modal-header">Teilnahmebedingugen</h3>
<p>
1. Willkommen bei publisher.linkvertise.com!
</p>
<p>
Vielen Dank für Ihr Interesse an unserem Unternehmen! Durch die Nutzung
unserer Dienste erklären Sie sich mit diesen Teilnahmebedingungen, den AGB
und den Programmrichtlinien einverstanden. Im Falle eines Konflikts gehen
die Teilnahmebedingungen den anderen Bestimmungen der Vereinbarung im
Umfang des Konflikts vor. Bitte lesen Sie die Vereinbarung sorgfältig. Im
Rahmen der Vereinbarung steht der Begriff „Sie“ oder „Benutzer“ für die
Einzelperson oder das Unternehmen, die/das die Dienste nutzt (bzw. und/oder
eine Einzelperson, ein Unternehmen oder dessen Rechtsnachfolger, eine
Agentur oder ein Netzwerk, die/das in Ihrem Namen handelt); „wir“, „uns“
oder „publisher.linkvertise.com“ steht für unser Unternehmen.
</p>
<p>
2. Zugriff auf die Dienste; Benutzer-Konten
</p>
<p>
Ihre Nutzung der Dienste ist davon abhängig, dass Sie ein Benutzer-Konto
erstellen und Sie dieses ausreichend einrichten. Wir haben das Recht, Ihren
Zugriff auf die Dienste zu verweigern oder zu begrenzen.
</p>
<p>
Durch Ihre Anmeldung bei publisher.linkvertise.com gestatten Sie es uns, Werbung und
andere Inhalte („Anzeigen“) bei Ihren erstellten Links auszuliefern.
</p>
<p>
3. Nutzung unserer Dienste
</p>
<p>
Sie dürfen unsere Dienste nur entsprechend dieser Vereinbarung und im
Einklang mit den geltenden Gesetzen nutzen. Wir bitten Sie, unsere Dienste
nicht zu missbrauchen. Z.B. dürfen Sie unsere Dienste nicht beeinträchtigen
oder versuchen, auf diese mit Hilfe einer anderen Methode als der von uns
bereitgestellten Schnittstelle oder abweichend von unseren Anleitungen,
zuzugreifen.
</p>
<p>
4. Änderungen an unseren Diensten; Änderungen an der Vereinbarung
</p>
<p>
Unsere Dienste werden kontinuierlich verändert und verbessert.
Dienstspezifische Funktionalitäten oder Funktionen können jederzeit
hinzugefügt oder entfernt werden; ferner können wir einen Dienst zeitweise
aussetzen oder insgesamt einstellen. Diese Vereinbarung kann von uns
jederzeit geändert werden. Etwaige Änderungen der Teilnahmebedingungen
werden auf dieser Seite und Änderungen der Programmrichtlinien auf den
jeweils für diese eingerichteten Seiten veröffentlicht. Änderungen treten
nicht rückwirkend in Kraft und werden in der Regel 14 Tage, nachdem sie
veröffentlicht wurden, wirksam. Hingegen erlangen Änderungen, die neue
Funktionen eines Dienstes betreffen oder aus rechtlichen Gründen
vorgenommen werden, umgehende Wirksamkeit. Wenn Sie mit irgendwelchen der
abgeänderten Bedingungen in der Vereinbarung nicht einverstanden sind,
müssen Sie die Nutzung der davon betroffenen Dienste einstellen.
</p>
<p>
5. Zahlungen
</p>
<p>
Nach Maßgabe dieser Ziffer 5 und der Ziffer 10 dieser Teilnahmebedingungen
erhalten Sie eine jeweils von publisher.linkvertise.com festgelegte Zahlung
entsprechend der Anzahl der gültigen Impressions auf ihre Links.
</p>
<p>
Außer im Fall einer Kündigung, erbringen wir unsere Zahlung zum Ende des
jeweiligen Kalendermonats, der auf jeglichen Monat folgt, in dem Ihr
Kontostand die anwendbare Auszahlungsschwelle(10 Euro) erreicht oder
darüber liegt.
</p>
<p>
Soweit von publisher.linkvertise.com nicht ausdrücklich schriftlich genehmigt, ist es
Ihnen untersagt, Verabredungen jeglicher Art mit einem Dritten zu treffen,
wonach dieser Dritte unter dieser Vereinbarung an Sie zu leistende
Zahlungen oder andere finanzielle Vorteile mit Bezug zu den Diensten
erhält.
</p>
<p>
Zahlungen werden allein auf der Grundlage unserer Abrechnungen ermittelt.
An Sie zu leistende Zahlungen können zurückbehalten oder angepasst werden,
soweit Werbeanbietern entsprechende Beträge gutgeschrieben oder
zurückerstattet werden oder es sich um Beträge aus ungültigen Aktivitäten,
wie von publisher.linkvertise.com nach eigenem Ermessen festgelegt, handelt.
Ungültige Aktivitäten werden ausschließlich von publisher.linkvertise.com bestimmt
und umfassen, ohne jedoch hierauf begrenzt zu sein, (i) Spam, ungültige
Anfragen oder ungültige Besucher auf Beiträge, die durch eine Person, Bot,
automatisches Programm oder eine ähnliche Vorrichtung generiert werden,
einschließlich Besucher, die von Ihrer IP-Adresse oder von Rechnern unter
Ihrer Kontrolle ausgehen; (ii) durch Geldzahlungen, falsche Angaben oder an
Endnutzer gerichtete Aufforderungen.
</p>
<p>
Zusätzlich zu unseren weiteren Rechten und Rechtsbehelfen können wir (a)
Ihnen unter dieser Vereinbarung geschuldete Zahlungen zurückbehalten und
diese mit etwaigen Entgelten, die Sie uns unter dieser oder einer anderen
Vereinbarung schulden, verrechnen; oder (b) Sie verpflichten, uns binnen 30
Tagen nach Rechnungsstellung Beträge, die wir Ihnen in vorangegangenen
Zahlungsperioden zuviel bezahlt haben, zurückzuerstatten. Wenn Sie eine im
Zusammenhang mit den Diensten getätigte oder zurückbehaltene Zahlung
anfechten wollen, müssen sie dies publisher.linkvertise.com binnen 30 Tagen nach
einer solchen Zahlung schriftlich mitteilen (E-Mail: <a href="index.html" class="__cf_email__" data-cfemail="d9b0b7bfb699a9acbbb5b0aab1bcabf7b5b0b7b2afbcabadb0aabcf7bab6b4">[email&#160;protected]</a>).
Tun Sie dies nicht, verzichten Sie auf jegliche Forderung im Zusammenhang
mit der angefochtenen Zahlung.
</p>
<p>
Um eine ordnungsgemäße Abwicklung von Zahlungen zu gewährleisten, sind sie
dafür verantwortlich, korrekte Kontakt- und Zahlungsinformationen in Ihrem
Konto bereitzustellen und diese aktuell zu halten. Etwaig anfallende Bank-/
PayPalgebühren sind von Ihnen zu tragen.
</p>
<p>
6. Datenschutz
</p>
<p>
In unserer <u>Datenschutzerklärung</u> ist beschrieben, wie wir Ihre
personenbezogenen Daten verwenden und ihre Privatsphäre schützen, wenn Sie
unsere Dienste nutzen.
</p>
<p>
7. Vertraulichkeit
</p>
<p>
Sie verpflichten sich, ohne unsere vorherige schriftliche Genehmigung keine
vertraulichen Informationen von publisher.linkvertise.com offenzulegen. Ihnen ist es
jedoch erlaubt, Ihre Gesamt-Einnahmen mit unserer Website offenzulegen.
</p>
<p>
8. Kündigung
</p>
<p>
Diese Vereinbarung kann jederzeit mittels Durchführung eines
Kontenschließungsantrages gekündigt werden.
</p>
<p>
Wird die Vereinbarung unsererseits wegen einer Vertragsverletzung durch Sie
oder einer ungültigen Aktivität gleich aus welchem Grund gekündigt, können
nicht ausgezahlte Beträge einbehalten oder Beträge Ihrem Konto rückbelastet
werden. Wenn Sie gegen die Vereinbarung verstoßen oder publisher.linkvertise.com ihr
Konto suspendiert oder kündigt, ist Ihnen die Erstellung eines neuen Kontos
untersagt.
</p>
<p>
9. Zusicherungen; Gewährleistungen; Disclaimer
</p>
<p>
Sie sichern zu und gewährleisten, dass (i) Sie vollumfänglich ermächtigt
und befugt sind, diese Vereinbarung abzuschließen; dass (ii) ein von Ihnen
erstelltes Benutzer-Konto nie zuvor von publisher.linkvertise.com wegen einer von
Ihnen begangenen Vertragsverletzung oder einer ungültigen Aktivität
gekündigt oder anderweitig deaktiviert wurde; und dass (ii) alle
Informationen, die Sie publisher.linkvertise.com gegenüber bereitstellen, korrekt und
aktuell sind.
</p>
<p>
10. Freistellung
</p>
<p>
Sie verpflichten sich, publisher.linkvertise.com, seine verbundenen Unternehmen,
Vertreter und Werbeanbieter gegen sämtliche Inanspruchnahmen durch Dritte
sowie gegen Verantwortlichkeiten gegenüber Dritten, die sich aus oder im
Zusammenhang mit den
</p>
<p>
erstellten Links ergeben, zu verteidigen und diese schadlos zu halten.
</p>
<p>
11. Haftungsbegrenzung
</p>
<p>
Nichts in dieser Vereinbarung beschränkt oder schließt die Haftung einer
Partei für die folgenden Vorkommnisse aus: (a) Betrug oder falsche
Darstellungen in betrügerischer Absicht; (b) Tod oder Körperverletzung
aufgrund von Fahrlässigkeit; oder (c) anderweitige Vorkommnisse, für die
die Haftung nach dem Gesetz nicht ausgeschlossen oder beschränkt werden
kann. Keine der Parteien haftet unter oder im Zusammenhang mit der
Vereinbarung (ungeachtet, ob aus Vertrag, Delikt oder aus anderen Gründen)
für etwaige indirekte, Sonder- oder Folgeschäden (unabhänging davon, ob ein
solcher Verlust vorhersehbar oder bekannt war und unabhängig von sonstigen
Gründen). Die gesamte Haftung einer jeden der Parteien unter oder im
Zusammenhang mit der Vereinbarung (ob aus Vertrag, Delikt oder anderen
Gründen) soll keinesfalls 50 % des von publisher.linkvertise.com an Sie in dem
Zwölfmonatszeitraum unmittelbar vor dem frühesten Datum, ab dem eine solche
Haftung bestand, gezahlten Nettobetrages übersteigen. Die
Haftungsbegrenzungen und -ausschlüsse in dieser Ziffer 11 gelten nicht in
Bezug auf eine etwaige Haftung Ihrerseits nach Ziffer 7 (Vertraulichkeit)
oder Ziffer 12 (Freistellung).
</p>
<p>
12. Rechtseinräumung
</p>
<p>
Sie dürfen nur auf eigene Inhalte verlinken bzw. auf Inhalte, deren Nutzungsrechte Ihnen im hierfür erforderlichen Umfang exklusiv eingeräumt wurden (siehe zu weiteren unzulässigen Verlinkungen auch unsere Programmrichtlinien). Mit der Umwandlung Ihres Deeplinks in einen Linkvertise-Link räumen Sie uns die ausschließlichen Nutzungsrechte ein, Ihren Deeplink sowie den über den Deeplink zu findenden Inhalt öffentlich zugänglich zu machen bzw. öffentlich zugänglich machen zu lassen.
</p>
<p>
13. Verschiedenes
</p>
<p>
<em><strong>Gesamte Vereinbarung; Änderungen. </strong></em>
Die vorliegende Vereinbarung stellt unsere vollständige Vereinbarung
bezüglich Ihrer Nutzung der Dienste dar und geht allen vorherigen oder
gleichzeitigen Vereinbarungen zu diesem Vertragsgegenstand vor. Keiner der
Parteien steht ein Recht oder Rechtsbehelf basierend auf einer Aussage,
Zusicherung oder Garantie zu (unabhängig davon, ob diese fahrlässig oder
schuldlos gemacht wurde), die nicht ausdrücklich in der Vereinbarung
geregelt ist. Diese Vereinbarung kann nur schriftlich von uns geändert
werden.
</p>
<p>
<em><strong>Abtretung.</strong></em>
Ihre Rechte gemäß der vorliegenden Vereinbarung sind weder abtret- noch
übertragbar.
</p>
<p>
<em><strong>Keine Drittbegünstigten. </strong></em>
Durch diese Vereinbarung sollen keine Rechte zugunsten Dritter entstehen.
</p>
<p>
<em><strong>Salvatorische Klausel.</strong></em>
Stellt sich heraus, dass eine bestimmte Regelung der Vereinbarung nicht
durchsetzbar ist, bleibt der Rest der Vereinbarung davon unberührt.
</p>
<p>
<em><strong>Fortgelten. </strong></em>
Die Teilnahmebedingungen gelten auch nach Kündigung der Vereinbarung fort.
</p>
 <p>
<em><strong>Höhere Gewalt.</strong></em>
Keine der Parteien haftet für mangelhafte Vertragserfüllung, soweit diese
auf einen Zustand zurückzuführen ist, der außerhalb der vernünftigen
Kontrolle der jeweiligen Partei liegt (beispielsweise Naturkatastrophen,
kriegerische oder terroristische Handlungen, Aufstände, Streiks, staatliche
Handlungen und Internetstörungen).
</p>
<p>
<em><strong>Mitteilungen. </strong></em>
Im Zusammenhang mit Ihrer Nutzung der Dienste kann es sein, dass wir Sie
mit Dienstbekanntmachungen, administrativen Nachrichten und anderen
Informationen kontaktieren.
</p>
<p>
<em><strong>Anwendbares Recht; Gerichtsstand.</strong></em>
Die Vereinbarung unterliegt dem deutschen Recht und die Parteien
unterwerfen sich für alle Streitigkeiten, die die Vereinbarung betreffen
(unabhängig davon, ob aus Vertrag oder nicht-vertraglich), der
ausschließlichen Gerichtsbarkeit der deutschen Gerichte.
</p>
</div>
</div>
</div>
</div>
<div class="modal fade" id="modal_programm_kurz">
<div class="modal-dialog modal-lg">
<div class="modal-content">
<div class="modal-body">
<button type="button" class="close" data-dismiss="modal">&times;</button>
<h3 class="modal-header">FAQ</h3>
<h2>
<u>1. Generelle Fragen</u>
</h2>
<h4>
1.1. Was ist publisher.linkvertise.com?
</h4>
<p>
publisher.linkvertise.com ist eine Website, bei der man durch das kürzen von Links
Geld verdienen kann.
</p>
<p>
Kürzt ein Linkvertise Nutzer ein beliebigen Link wird vor der eigentlichen
Zielseite Werbung geschaltet. Die kommt gewöhnlich ohne Popups, Popunders
oder nervigen Layers aus. Das sorgt für eine gute Nutzererfahrung.
</p>
<p>
Klickt nun ein Nutzer auf diesen gekürzten Link, verdient der, der den Link
gekürzt hat, Geld.
</p>
<h4>
1.2. Darf man mehr als ein Account besitzen?
</h4>
<p>
Eine Person darf lediglich ein Linkvertise Account besitzen.
</p>
<h4>
1.3. Wie kann man Kontakt für dingenden Support aufnehmen?
</h4>
<p>
Sofern Sie in diesem FAQ keine Antwort auf ihre Frage finden, können Sie
uns gerne über die E-Mail <a href="index.html#dcb5b2bab39cb8b5aeb9b7a8f1abb5afafb9b2f2bfb3b1"><span class="__cf_email__" data-cfemail="244d4a424b64">[email&#160;protected]</span></a>
publisher.linkvertise.com kontaktieren. Wir kümmern uns schnellstmöglichst um ihr
Problem, ihre Frage oder Anmerkung.
</p>
<p>
Für wirklich dringliche Supportanfragen bieten wir ein Whatsapp-Support an.
Unter folgender Nummer können Sie uns über Whatsapp kontaktieren: 01516
4598793
 </p>
<h4>
1.4. Darf ich jede Website verlinken?
</h4>
<p>
Nein, es dürfen beispielsweise keine Websites verlinkt werden, die
pornografischen Inhalt besitzen oder Viren verteilen. Weitere Informationen
dazu erhalten Sie bei unseren <u>Programmrichtlinien</u>.
</p>
<h4>
1.5. Darf schon gekürzte Links ineinander verlinken?
</h4>
<p>
Nein, Sie dürfen ein schon gekürzten Link nicht noch einmal in einem
unserer Links kürzen. Das verwirrt den Endnutzer.
</p>
<h2>
<u>2. Ihre Daten</u>
</h2>
<h4>
2.1. Was passiert mit meinen Daten?
</h4>
<p>
Laut unseren Datenschutzerklärung wird mit ihren persönlichen Daten sorgsam
umgegangen. Sie können zudem Verlinkungen vornehmen, ohne die Adresse, bzw.
den vollen Namen angeben zu müssen. Wenn es jedoch zu einer Auszahlung des
Guthabens kommen sollte, benötigen wir ihre Adressdaten und den genauen
Namen, um festzustellen, dass Sie eine reale Person sind.
</p>
<h4>
2.2. Kann man sein eigenen Account wieder löschen?
</h4>
<p>
Ein Account kann in der Regel nicht gelöscht werden. Auf Anfrage können Sie
aber ihr Account deaktivieren lassen.
</p>
<h2>
<u>3. Auszahlungen und Gutschriften</u>
</h2>
<h4>
3.1. Wie berechnet sich die Vergütung pro Besucher?
</h4>
<p>
Der Algorithmus für die Berechnung gültiger Besucher ist geheim, um
Missbrauch zu vermeiden. Sie können aber davon ausgehen, dass Links, bei
denen oft auf den "Weiter Button" geklickt wird, besser vergütet werden,
als Links bei den dies nicht geschieht. Es kommt aber auch auf eine gesunde
Mischung an Klicks und Ansichten an, um eine hohe Vergütung zu erzielen.
</p>
<p>
Die Herkunft des Traffics ist auch relevant. Derzeit wird D-A-CH Traffic am
höhsten vergütet.
</p>
<h4>
3.2. Wann wird mein Guthaben ausgezahlt?
</h4>
<p>
Das Guthaben kann per "Guthaben auszahlen" Button ausgezahlt werden. Es ist
jedoch zu beachten, dass man maximal drei mal pro Monat die Möglichkeit
bekommt, einen Betrag über 10 Euro auszuzahlen. Wann diese drei Male sein
sollen, können Sie selbst bestimmen. Für die Bearbeitung eines
Auszahlungsantrages haben wir uns sieben Tage vorgesetzt. In der Regel
geschieht die Auszahlung aber innerhalb weniger Tage.
</p>
<p>
Bei Gutscheinen wie Paysafecards oder Amazon Gutscheinen, steht ihnen der
Code direkt zur Verfügung.
</p>
<h4>
3.3. Welche Auszahlungsmethoden gibt es?
</h4>
<p>
Auszahlung per
</p>
<p>
• Banküberweisung
</p>
<p>
• PayPal
</p>
<p>
• Paysafecard
</p>
<p>
• Amazon Gutschein
</p>
<h4>
3.4. Bekomme ich eine Abrechnungsgutschrift für eine Auszahlung?
</h4>
<p>
Sie haben die Möglichkeit, nach jeder Auszahlung eine Abrechnungsgutschrift
per PDF-Dokument zu downloaden. Dort wird ihnen ihr ausgezahltes Guthaben
inklusiv Mehrwertsteuer aufgelistet.
</p>
<h2>
<u>4. Das Affiliate System</u>
</h2>
<h4>
4.1. Wie lange ist die Cookie Laufzeit?
</h4>
<p>
Die Cookie-Laufzeit für unser Affiliate-Programm beträgt 24 Monate.
</p>
<h4>
4.2. Wie lange bekomme ich die Provision für angeworbene Linkvertise
Nutzer?
</h4>
<p>
Sie erhalten ihre Provision für angeworbene Linkvertise Nutzer solange, bis
diese ihre Links wieder löschen oder deren Account deaktiviert wird.
</p>
<h2>
<u>5. Kontosperrung</u>
</h2>
<h4>
5.1. Was passiert nach einer Kontosperrung?
</h4>
<p>
Ist ihr Konto aufgrund missbräuchlichem Verhalten gesperrt worden, ist es
ihnen als Person untersagt, sich erneut ein Account bei publisher.linkvertise.com zu
erstellen. Sollten Sie dennoch versuchen, unsere Systeme zu umgehen oder
dem Unternehmen andersweitig zu schaden, fühlen wir uns gezwungen,
rechtliche Maßnahmen zu ergreifen.
</p>
<h4>
5.2. Was sind die häufigsten Gründe für Kontosperrungen?
</h4>
<p>
Die meisten Kontosperrungen müssen wir aufgrund von Verstößen gegen unsere
Programmrichtlinien erteilen. Bitte machen Sie sich besonders mit den
Programmrichtlinien vertraut, um Komplikationen zu vermeiden.
</p>
<p>
Uns liegt viel an einer guten Zusammenarbeit.
</p>
</div>
</div>
</div>
</div>
<div class="modal fade" id="modal_datenschutz">
<div class="modal-dialog modal-lg">
<div class="modal-content">
<div class="modal-header">
<div class="float-left">
<div class="headline">
Data Protection
</div>
</div>
<div class="float-right close-btn" data-dismiss="modal"><i class="fa fa-times pointer"></i></div>
</div>
<div class="modal-body">
 The collection and use of personal data of the users of our website takes place exclusively in compliance with the data protection laws of the Federal Republic of Germany. In the following, we will inform you about the nature, extent and purpose of collecting and using your personal data. The information about privacy can be accessed on this website constantly.<br><br>Responsible<br>Marc Winter<br>Fraunhoferstraße 3<br>25524 Itzehoe<br>Germany<br><br>Types of processed data:<br><ul> <li>Inventory data (e.g., names, addresses, payment methods).</li><li>Contact information (e.g., e-mail, phone numbers).</li><li>Content data (e.g., text input, photographs, videos).</li><li>Usage data (e.g., websites visited, interest in content, access times).</li><li>Meta / communication data (e.g., device information, IP addresses).</li></ul>Categories of affected persons<br>Visitors and users of the online offer (hereinafter we refer to the affected persons as "users").<br><br>Purpose of processing<br><ul> <li>Provision of the online offer, its functions and contents.</li><li>Answering contact requests and communicating with users.</li><li>Safety measures.</li><li>Reach Measurement / Marketing</li></ul><span class="test">Used terms</span><br><br>"Personal data" means any information relating to an identified or identifiable natural person (hereinafter the "data subject"); a natural person is regarded as identifiable, which can be identified directly or indirectly, in particular by means of assignment to an identifier such as a name, to an identification number, to location data, to an online identifier (eg cookie) or to one or more special features, are the expression of the physical, physiological, genetic, mental, economic, cultural or social identity of this natural person.<br><br>"Processing" means any process performed with or without the aid of automated procedures, or any such process associated with personal data. The term goes far and includes virtually every handling of data.<br><br>"Pseudonymisation" means the processing of personal data in such a way that the personal data can no longer be assigned to a specific data subject without additional information being provided, provided that such additional information is kept separate and subject to technical and organizational measures to ensure that the personal data not assigned to an identified or identifiable natural person.<br><br>"Profiling" means any kind of automated processing of personal data which involves the use of such personal data to evaluate certain personal aspects relating to a natural person, in particular aspects relating to job performance, economic situation, health, personal To analyze or predict preferences, interests, reliability, behavior, whereabouts, or relocation of that natural person.<br><br>'Responsible person' means the natural or legal person, public authority, body or body which, alone or in concert with others, decides on the purposes and means of processing personal data.<br><br>"Processor" means a natural or legal person, public authority, body or body that processes personal data on behalf of the controller.<br><br><span class="test">Relevant legal bases</span><br><br>In accordance with Art. 13 GDPR, we inform you about the legal basis of our data processing. Unless the legal basis in the data protection declaration is mentioned, the following applies: The legal basis for obtaining consent is Article 6 (1) lit. a and Art. 7 GDPR, the legal basis for the processing for the performance of our services and the execution of contractual measures as well as the answer to inquiries is Art. 6 para. 1 lit. b GDPR, the legal basis for processing in order to fulfill our legal obligations is Art. 6 (1) lit. c GDPR, and the legal basis for processing in order to safeguard our legitimate interests is Article 6 (1) lit. f GDPR. In the event that vital interests of the data subject or another natural person require the processing of personal data, Art. 6 para. 1 lit. d GDPR as legal basis.<br><br><span class="test">Safety measures</span><br><br>We take appropriate technical measures in accordance with Art. 32 GDPR, taking into account the state of the art, the implementation costs and the nature, scope, circumstances and purposes of the processing as well as the different likelihood and severity of the risk to the rights and freedoms of natural persons and organizational measures to ensure a level of protection appropriate to the risk.<br><br>Measures include, in particular, ensuring the confidentiality, integrity and availability of data by controlling physical access to the data, as well as their access, input, disclosure, availability and segregation. In addition, we have established procedures to ensure the enjoyment of data subject rights, the erasure of data and the response to data threats. Furthermore, we consider the protection of personal data already in the development, or selection of hardware, software and procedures, according to the principle of data protection by technology design and privacy-friendly default settings (Article 25 GDPR).<br><br><span class="test">Collaboration with processors and third parties</span><br><br>If, in the context of our processing, we disclose data to other persons and companies (processors or third parties), transmit them to them or otherwise grant access to the data, this is done only on the basis of a legal permission (eg if a transmission of the data to third parties, as required by payment service providers, pursuant to Art. 6 (1) (b) GDPR to fulfill the contract), you have consented to a legal obligation or on the basis of our legitimate interests (eg the use of agents, webhosters, etc.).<br><br>Insofar as we commission third parties to process data on the basis of a so-called "contract processing contract", this is done on the basis of Art. 28 GDPR.<br><br><span class="test">Transfers to third countries</span><br><br>If we process data in a third country (ie outside the European Union (EU) or the European Economic Area (EEA)) or in the context of the use of third party services or disclosure, or transmission of data to third parties, this will only be done if it is to fulfill our (pre) contractual obligations, on the basis of your consent, on the basis of a legal obligation or on the basis of our legitimate interests. Subject to legal or contractual permissions, we process or have the data processed in a third country only in the presence of the special requirements of Art. 44 et seq. GDPR. That the processing is e.g. on the basis of specific guarantees, such as the officially recognized level of data protection (eg US for the USA) "Privacy Shield") or observance of officially recognized special contractual obligations (so-called "standard contractual clauses").<br><br><span class="test">Rights of data subjects</span><br><br>You have the right to request a confirmation as to whether the data in question is being processed and for information about this data as well as for further information and a copy of the data in accordance with Art. 15 GDPR.<br><br>You have accordingly. Art. 16 GDPR the right to demand the completion of the data concerning you or the correction of the incorrect data concerning you.<br><br>In accordance with Art. 17 GDPR, they have the right to demand that the relevant data be deleted immediately or, alternatively, to require a restriction of the processing of data in accordance with Art. 18 GDPR.<br><br>You have the right to demand that the data relating to you, which you have provided to us, be obtained in accordance with Art. 20 GDPR and request their transmission to other responsible persons.<br><br>You have gem. Art. 77 GDPR the right to file a complaint with the competent supervisory authority.<br><br><span class="test">Revocation</span><br><br>You have the right to consent according to. Art. 7 para. 3 GDPR with effect for the future.<br><br><span class="test">Right to object</span><br><br>You may at any time object to the future processing of your data in accordance with Art. 21 GDPR. The objection may in particular be made against processing for direct marketing purposes.<br><br>< class="test">Cookies and right to object to direct mail<br>"Cookies" are small files that are stored on users' computers. Different information can be stored within the cookies. A cookie serves primarily to store the information about a user (or the device on which the cookie is stored) during or after his visit to an online offer. Temporary cookies, or "session cookies" or "transient cookies", are cookies that are deleted after a user leaves an online service and closes his browser. In such a cookie, e.g. the contents of a shopping cart are stored in an online shop or a login status. As "permanent" or<br><br>"Persistent" means cookies that remain stored even after the browser has been closed. Thus, e.g. the login status will be saved if users visit it after several days. Likewise, in such a cookie the interests of the users can be stored, which are used for range measurement or marketing purposes. A "third-party cookie" refers to cookies that are offered by providers other than the person responsible for providing the online offer (otherwise, if only their cookies are called "first-party cookies").<br><br>We can use temporary and permanent cookies and clarify this in the context of our privacy policy.<br><br>If users do not want cookies stored on their machine, they will be asked to disable the option in their browser's system settings. Saved cookies can be deleted in the system settings of the browser. The exclusion of cookies can lead to functional restrictions of this online offer.<br><br>A general objection to the use of cookies used for online marketing purposes can be found in a variety of services, especially in the case of tracking, via the US website http://www.aboutads.info/choices/ or the EU website http://www.youronlinechoices.com/ be explained. Furthermore, the storage of cookies can be achieved by switching them off in the settings of the browser. Please note that not all features of this online offer may be used.<br><br><span class="test">Deletion of data</span><br><br>The data processed by us are deleted or limited in their processing in accordance with Articles 17 and 18 GDPR. Unless explicitly stated in this privacy statement, the data stored by us will be deleted as soon as they are no longer necessary for their intended purpose and the deletion does not conflict with any statutory storage requirements. Unless the data is deleted because it is required for other and legally permitted purposes, its processing will be restricted. That the data is blocked and not processed for other purposes. This applies, for example for data that must be kept for commercial or tax reasons.<br><br>According to legal requirements in Germany, the storage takes place in particular for 10 years according to §§ 147 Abs. 1 AO, 257 Abs. 1 Nr. 1 and 4, Abs. 4 HGB (books, records, management reports, accounting documents, trading books, for taxation relevant Documents, etc.) and 6 years in accordance with § 257 (1) no. 2 and 3, para. 4 HGB (commercial letters).<br><br>According to legal regulations in Austria the storage takes place in particular for 7 J in accordance with § 132 exp. 1 BAO (accounting documents, receipts / invoices, accounts, documents, business papers, statement of income and expenses, etc.), for 22 years in connection with land and for 10 years in the case of documents related to electronically supplied services, telecommunications, broadcasting and television services provided to non-EU companies in EU Member States for which the Mini-One-Stop-Shop (MOSS) is used.<br><br><span class="test">Contractual services</span><br><br>We process the data of our contractual partners and interested parties as well as other clients, customers, clients, clients or contractual partners (uniformly referred to as "Contractual Partner") in accordance with Art. 6 para. 1 lit. b. GDPR in order to provide you with our contractual or pre-contractual services. The data processed, the nature, scope and purpose and necessity of their processing are determined by the underlying contractual relationship.<br><br>The processed data includes the master data of our contractual partners (eg, names and addresses), contact data (eg e-mail addresses and telephone numbers) as well as contract data (eg, services used, contract contents, contractual communication, names of contact persons) and payment data (eg, Bank details, payment history).<br><br>In principle, we do not process special categories of personal data, unless these components are the subject of a commissioned or contractual processing.<br><br>We process data that are necessary for the establishment and fulfillment of the contractual services and point out the necessity of their information, if this is not evident for the contractual partners. Disclosure to external persons or companies will only be made if required by a contract. When processing the data provided to us within the framework of an order, we act in accordance with the instructions of the client as well as with the legal requirements.<br><br>As part of the use of our online services, we can save the IP address and the time of the respective user action. The storage is based on our legitimate interests, as well as the interests of the user in the protection against misuse and other unauthorized use. A transfer of this data to third parties is not, unless it is to pursue our claims acc. Art. 6 para. 1 lit. f. GDPR required or there is a legal obligation gem. Art. 6 para. 1 lit. c. GDPR.<br><br>The data is deleted if the data is no longer required for the fulfillment of contractual or legal duties of care and for handling any warranty and comparable obligations, whereby the necessity of keeping the data is reviewed every three years; otherwise the statutory storage obligations apply.<br><br><span class="test">External payment service providers</span><br><br>We use external payment service providers whose platforms allow users and we to make payment transactions. The following lists the payment providers used with a link to the privacy policy:<br><ul> <li>Paypal (paypal.com/webapps/mpp/ua/privacy-full)</li><li>Klarna (klarna.com/de/datenschutz/)</li><li>Google Pay (policies.google.com/privacy)</li><li>Apple Pay (apple.com/legal/privacy/en-ww/)</li><li>Amazon Pay (pay.amazon.de/help/201212490)</li><li>Visa (visa.de/datenschutz)</li><li>Mastercard (mastercard.de/de- de / datenschutz.html)</li><li>American Express (americanexpress.com/en/content/privacy-policy-statement.html)</li></ul>As part of the fulfillment of contracts, we set the payment service providers on the basis of Art. 6 para. 1 lit. b. GDPR. Incidentally, we use external payment service providers on the basis of our legitimate interests. Art. 6 para. 1 lit. b. GDPR in order to offer our users effective and secure payment options.<br><br>Amongst the data processed by the payment service providers are inventory data, e.g. the name and the address, bank data, e.g. Account numbers or credit card numbers, passwords, TANs and checksums as well as contract, summary and recipient related information. The information is required to complete the transactions. However, the data entered will only be processed and stored by the payment service providers. That We do not receive any account or credit card related information, but only information with confirmation or negative disclosure of the payment. The data may be transmitted by the payment service providers to credit reporting agencies. This transmission aims at the identity and credit check. For this we refer to the terms and conditions and privacy policy of payment service providers.<br><br>For the payment transactions, the terms and conditions and the privacy notices of the respective payment service providers, which are available within the respective websites, or transactional applications apply. We also refer to these for further information and assertion of rights of revocation, information and other data subjects.<br><br><span class="test">Administration, financial accounting, office organization, contact management</span><br><br>We process data in the context of administrative tasks and organization of our business, financial accounting and compliance with legal obligations, such as archiving. In doing so, we process the same data that we process in the course of rendering our contractual services. The processing principles are Art. 6 para. 1 lit. c. GDPR, Art. 6 para. 1 lit. f. GDPR. The processing affects customers, prospects, business partners and website visitors. The purpose and interest in processing lies in administration, financial accounting, office organization, data archiving, that is, tasks that serve to maintain our business, perform our duties and provide our services. The deletion of the data with regard to contractual services and contractual communication corresponds to the information provided in these processing activities.<br><br>We disclose or transmit data to the financial services, consultants such as tax accountants or auditors, and other fee agents and payment service providers.<br><br>Furthermore, based on our business interests, we store information about suppliers, promoters and other business partners, e.g. for later contact. We generally store this majority of company-related data permanently.<br><br><span class="test">Business analysis and market research</span><br><br>In order to operate our business economically, to be able to recognize market tendencies, wishes of the contractors and users, we analyze the data available to us for business transactions, contracts, inquiries, etc. We process stock data, communication data, contract data, payment data, usage data, metadata on the basis of Art 6 para. 1 lit. f. GDPR, whereby the data subjects include contractual partners, interested parties, customers, visitors and users of our online offer.<br><br>The analyzes are carried out for the purpose of business analysis, marketing and market research. In doing so, we can provide the profiles of the registered users with information, e.g. take into account their services. The analyzes serve us to increase the user-friendliness, the optimization of our offer and the business economy. The analyzes are for us alone and will not be disclosed externally unless they are anonymous, aggregated value analyzes.<br><br>If these analyzes or profiles are personal, they will be deleted or anonymised upon termination of the users, otherwise after two years from the conclusion of the contract. Incidentally, the overall business analyzes and general trend provisions are created anonymously if possible.<br><br><span class="test">Participation in Affiliate Affiliate Programs</span><br><br>Within our online offer, we rely on our legitimate interests (i.e., interest in the analysis, optimization and economical operation of our online offer) acc. Art. 6 para. 1 lit. f GDPR industry-standard tracking measures, as far as these are necessary for the operation of the affiliate system. Below we clarify the users about the technical background.<br><br>The services offered by our contractual partners can also be advertised and linked to other websites (so-called affiliate links or after-buy systems, if, for example, links or services of third parties are offered after conclusion of a contract). The operators of the respective websites receive a commission if users follow the affiliate links and then take advantage of the offers.<br><br>In conclusion, our online offering requires us to be able to keep track of whether users who are interested in affiliate links and / or the offers available to us, then take advantage of the offers on the affiliate links or our online platform. For this, the affiliate links and our offers are supplemented by certain values that are part of the link or otherwise, e.g. in a cookie, can be set. The values include in particular the source website (referrer), time, an online identifier of the operator of the website on which the affiliate link was located, an online identifier of the respective offer, an online identifier of the user, as well as tracking specific values such as Ad ID, affiliate ID, and categorizations.<br><br>The online user IDs used by us are pseudonymous values. That the online identifiers themselves do not contain personal data such as names or e-mail addresses. They only help us determine whether the same user who clicked on an affiliate link or was interested in an offer through our online offer, perceived the offer, i. e.g. has signed a contract with the provider. However, the online identification is personal insofar as the partner company and also us, the online identification together with other user data are available. Only then can the partner company tell us whether the user has taken the offer and we are e.g. can pay the bonus.<br><br><span class="test">Register function</span><br><br>Users can create a user account. As part of the registration, the required mandatory information is communicated to the users and based on Art. 6 para. 1 lit. b GDPR processed for purposes of providing the user account. The processed data include in particular the login information (name, password and an e-mail address). The data entered during registration will be used for the purpose of using the user account and its purpose.<br><br>Users may have access to information relevant to their user account, e.g. technical changes, be informed by e-mail. If users have terminated their user account, their data will be deleted with respect to the user account, subject to a statutory retention requirement. It is the responsibility of the users to secure their data upon termination prior to the end of the contract. We are entitled to irretrievably delete all user data stored during the term of the contract.<br><br>In the context of the use of our registration and registration functions as well as the use of the user account, the IP address and the time of the respective user action will be saved. The storage is based on our legitimate interests, as well as the user's protection against misuse and other unauthorized use. A transfer of these data to third parties does not take place, unless it is necessary for the pursuit of our claims or there is a legal obligation in accordance with. Art. 6 para. 1 lit. c GDPR. The IP addresses will be anonymized or deleted after 7 days at the latest.<br><br><span class="test">Comments and posts</span><br><br>If users leave comments or other contributions, their IP addresses based on our legitimate interests within the meaning of Art. 6 para. 1 lit. f. GDPR be stored for 7 days. This is for our own safety, if someone leaves illegal content in comments and contributions (insults, prohibited political propaganda, etc.). In this case, we may be sued for the comment or post and are therefore interested in the identity of the author.<br><br>Furthermore, we reserve the right, in accordance with our legitimate interests. Art. 6 para. 1 lit. f. GDPR to process the information of users for the purpose of spam detection.<br><br>The data provided in the comments and contributions are stored by us permanently until the users object.<br><br><span class="test">Contact</span><br><br>When contacting us (for example, by contact form, e-mail, telephone or via social media), the information of the user to process the contact request and their processing acc. Art. 6 para. 1 lit. b) GDPR processed. User information can be stored in a Customer Relationship Management System ("CRM System") or comparable request organization.<br><br>We delete the requests, if they are no longer required. We check the requirement every two years; Furthermore, the legal archiving obligations apply.<br><br><span class="test">Google Tag Manager</span><br><br>Google Tag Manager is a solution that allows us to manage so-called web site tags through one interface (including integrating Google Analytics and other Google marketing services into our online offering). The tag manager itself (which implements the tags) does not process users' personal data. With regard to the processing of users' personal data, reference is made to the following information about the Google services. Usage Policy: https://www.google.com/intl/en/tagmanager/use-policy.html.<br><br><span class="test">Google Analytics</span><br><br>We use Google Analytics, a web analytics service of Google LLC ("Google"), based on our legitimate interests (i.e., interest in the analysis, optimization, and economic operation of our online service as defined in Art. 6 (1) lit. Google uses cookies. The information generated by the cookie about the use of the online offer by the users are usually transmitted to a Google server in the USA and stored there.<br><br>Google is certified under the Privacy Shield Agreement, which provides a guarantee to comply with European privacy legislation (https://www.privacyshield.gov/participant?id=a2zt000000001L5AAI&status=Active).<br><br>Google will use this information on our behalf to evaluate the use of our online offer by users, to compile reports on the activities within this online offering and to provide us with further services related to the use of this online offer and the internet usage. In this case, pseudonymous user profiles of the processed data can be created.<br><br>We only use Google Analytics with activated IP anonymization. This means that the IP address of the users is shortened by Google within member states of the European Union or in other contracting states of the Agreement on the European Economic Area. Only in exceptional cases will the full IP address be sent to a Google server in the US and shortened there.<br><br>The IP address submitted by the user's browser will not be merged with other data provided by Google. Users can prevent the storage of cookies by setting their browser software accordingly; Users may also prevent the collection by Google of the data generated by the cookie and related to their use of the online offer as well as the processing of such data by Google by downloading and installing the browser plug-in available under the following link: http://tools.google.com/dlpage/gaoptout?hl=en.<br><br>For more information about Google's data usage, hiring and disparaging options, please read Google's Privacy Policy (https://policies.google.com/technologies/ads) and Google's Ads Ads Settings (https: // adssettings.google.com/authenticated).<br><br>The personal data of users will be deleted or anonymized after 14 months.<br><br><span class="test">Targeting with Google Analytics</span><br><br>We use Google Analytics to display the advertisements displayed within Google and its affiliate advertising services, only those users who have shown an interest in our online offering or who have certain characteristics (eg, interest in specific topics or products that they use) Web pages) that we submit to Google (so-called "remarketing" or "Google Analytics audiences"). With Remarketing Audiences, we also want to make sure that our ads meet the potential interest of users.<br><br><span class="test">Google Adsense with personalized ads</span><br><br>We use the services of Google LLC, 1600 Amphitheater Parkway, Mountain View, CA 94043 on the basis of our legitimate interests (ie interest in the analysis, optimization and economic operation of our online service within the meaning of Art. 6 (1) lit. GDPR) , USA, ("Google").<br><br>Google is certified under the Privacy Shield Agreement, which provides a guarantee to comply with European privacy legislation (https://www.privacyshield.gov/participant?id=a2zt000000001L5AAI&status=Active).<br><br>We use the AdSense service, which allows ads to appear on our website and reward us for their display or other use. For these purposes, usage data, such as the click on an ad and the IP address of the users processed, whereby the IP address is shortened by the last two places. Therefore, the processing of the data of the users is pseudonymized.<br><br>We use Adsense with personalized ads. In doing so, Google draws conclusions about their interests on the basis of the websites visited by users or used apps and the user profiles created in this way. Advertisers use this information to align their campaigns with these interests, which benefits users and advertisers alike. For Google, ads are personalized when collected or known data determines or influences ad selection. These include previous searches, activities, site visits, apps, demographics, and location information. Specifically, this includes demographic targeting, interest category targeting, remarketing, and targeting of customer matching lists and audience lists uploaded to DoubleClick Bid Manager or Campaign Manager.<br><br>For more information about Google's data usage, hiring and disparaging options, please read Google's Privacy Policy (https://policies.google.com/technologies/ads) and Google's Ads Ads Settings (https://adssettings.google.com/authenticated).<br><br><span class="test">Google Ads and conversion measurement</span><br><br>We use the services of Google LLC, 1600 Amphitheater Parkway, Mountain View, CA 94043 on the basis of our legitimate interests (ie interest in the analysis, optimization and economic operation of our online service within the meaning of Art. 6 (1) lit. GDPR) , USA, ("Google").<br><br>Google is certified under the Privacy Shield Agreement, which provides a guarantee to comply with European privacy legislation (https://www.privacyshield.gov/participant?id=a2zt000000001L5AAI&status=Active).<br><br>We use Google's online AdWords marketing tool "AdWords" to place ads on the Google Advertising Network (e.g., in search results, videos, websites, etc.) to display to users who have a suspected interest in the ads. This allows us to better target advertisements for and within our online offering so that we only present ads to users that potentially match their interests. If a user e.g. Showing ads for products he was looking for on other online offers is called remarketing. For these purposes, upon access to our and other websites where the Google Advertising Network is active, Google will immediately execute a Google code and become so-called (re) marketing tags (invisible graphics or code, also called " Web beacons") incorporated into the website. With their help, the user is provided with an individual cookie on the device. a small file is saved (instead of cookies, comparable technologies can be used). In this file is noted which web pages the user visited, for what content he is interested and what offers the user has clicked, as well as technical information about the browser and operating system, referring web pages, visit time and other information on the use of the online offer.<br><br>Furthermore, we receive an individual "conversion cookie". The information obtained through the cookie is used by Google to generate conversion statistics for us. However, we only hear about the anonymous total number of users who clicked on our ad and were redirected to a conversion tracking tag page. However, we do not receive information that personally identifies users.<br><br>The data of the users are pseudonym processed in the context of the Google advertising network. That Google stores and processes e.g. not the name or e-mail address of the users, but processes the relevant data cookie-related within pseudonymous user profiles. That from the perspective of Google, the ads are not managed and displayed to a specifically identified person, but to the cookie owner, regardless of who that cookie owner is. This does not apply if a user has expressly allowed Google to process the data without this pseudonymization. The information collected about users is transmitted to Google and stored on Google's servers in the United States.<br><br>For more information about Google's data usage, hiring and disparaging options, please read Google's Privacy Policy (https://policies.google.com/technologies/ads) and Google's Ads Ads Settings (https://adssettings.google.com/authenticated).<br><br><span class="test">Online presence in social media</span><br><br>We maintain online presence within social networks and platforms in order to communicate with customers, prospects and users active there and to inform them about our services. When calling the respective networks and platforms, the terms and conditions and the data processing guidelines apply to their respective operators.<br><br>Unless otherwise stated in our Privacy Policy, we process users' data as long as they communicate with us within social networks and platforms, e.g. Write posts on our online presence or send us messages.<br><br><span class="test">Integration of services and contents of third parties</span><br><br>Based on our legitimate interests (ie interest in the analysis, optimization and economic operation of our online offer within the meaning of Art. 6 (1) lit. GDPR), we make use of content or services offered by third-party providers in order to provide their content and services Services, such as Include videos or fonts (collectively referred to as "content").<br><br>This always presupposes that the third-party providers of this content perceive the IP address of the users, since they could not send the content to their browser without the IP address. The IP address is therefore required for the presentation of this content. We endeavor to use only content whose respective providers use the IP address only for the delivery of the content. Third parties may also use so-called pixel tags (invisible graphics, also referred to as "web beacons") for statistical or marketing purposes. The "pixel tags" can be used to evaluate information, such as visitor traffic, on the pages of this website. The pseudonymous information may also be stored in cookies on the user's device and may include, but is not limited to, technical information about the browser and operating system, referring web pages, time of visit, and other information regarding the use of our online offer.<br><br><span class="test">Vimeo</span><br><br>We may embed the videos of the Vimeo platform of Vimeo Inc., Attention: Legal Department, 555 West 18th Street New York, New York 10011, USA.<br><br>Privacy Policy: https://vimeo.com/privacy. We point out that Vimeo can use Google Analytics and refer to the privacy policy (https://www.google.com/policies/privacy) and opt-out options for Google Analytics (http://tools.google .com / dlpage / gaoptout? hl=en) or Google's data usage settings for marketing purposes (https://adssettings.google.com/).<br><br><span class="test">YouTube</span><br><br>We embed the videos on the YouTube platform of Google LLC, 1600 Amphitheater Parkway, Mountain View, CA 94043, USA. Privacy Policy: https://www.google.com/policies/privacy/, opt-out: https://adssettings.google.com/authenticated.<br><br><span class="test">Google ReCaptcha</span><br><br>We implement the function to detect bots, e.g. when entering into online forms ("ReCaptcha") of the provider Google LLC, 1600 Amphitheater Parkway, Mountain View, CA 94043, USA. Privacy Policy: https://www.google.com/policies/privacy/, opt-out: https://adssettings.google.com/authenticated.<br><br><span class="test">Twitter</span><br><br>Within our online offering, features and content of the Twitter service offered by Twitter, Inc., 1355 Market Street, Suite 900, San Francisco, CA 94103, USA, may be incorporated. For this, e.g. Content such as images, videos, or text and buttons that users use to promote their content, subscribe to content creators, or subscribe to our content. If the users are members of the platform Twitter, Twitter can call the o.g. Assign contents and functions to the user profiles there. Twitter is certified under the Privacy Shield Agreement, which provides a guarantee to comply with European privacy legislation (https://www.privacyshield.gov/participant?id=a2zt0000000TORzAAO&status=Active).<br><br>Privacy Policy: https://twitter.com/privacy, opt-out: https://twitter.com/personalization.<br><br><span class="test">Smartlook</span><br><br>We use within the scope of our legitimate interest in a technically flawless online offer and its economically efficient design and optimization in accordance with. Art. 6 (1) (f) GDPR the Smartlook analysis software from Smartsupp.com s.r.o., Milady Horakove 13, 602 00 Brno, Czech Republic. This tool captures movements on the observed web pages in so-called heatmaps. This allows us to anonymously recognize where visitors click and how far they scroll. This allows us to make our website better and more customer-friendly. Protecting your personal information is very important to us when using this tool. All data is collected without us being able to assign it to specific users. We can only understand how the mouse moves, where it was clicked, and how far scrolled. Further, the screen size of the device, the device type, information about the browser, the country from which it was accessed and the preferred language are recorded. If personal data of you or a third party is displayed on a website, smartlook automatically fills it. They are therefore incomprehensible to us). A "Do Not Track header" prevents the use of the Smartlook tool. Then no data will be collected about your visit to our website. For this you have to set your browser accordingly. A guide to German can be found at: http://www.akademie.de/wissen/do-not-track-datenschutz. The Smartlook tool alone can also be deactivated by means of the Opt out switch under: Smartlook Opt-Out. The Smartlook privacy policy can be found here: https://www.smartlook.com/en/privacy.<br><br><span class="test">Taboola</span><br><br>Our websites also use technologies from Taboola Inc. (28 West 23rd St. 5th Fl., New York, NY 10010, USA). Taboola uses cookies that are stored on your / your device and determine which of our pages you visit / visit, in order to refer to further, possibly also interesting content and to exploit usage-based advertising. Taboola collects information about your / your browser, your / your anonymized (shortened by the last octet) IP address. The cookie enables us to create pseudonymous user profiles by collecting protocol and device-related data in order to recommend suitable offers to you / you according to personal interests and to design our offer individually. For more information about Taboola and the ability to disable the Taboola cookie, please refer to / https://www.taboola.com/privacy-policy (opt-out information is available under "Site Visitor Choices").<br><br>With best regards<br>Marc Winter
</div>
</div>
</div>
</div>
<div class="modal fade" id="modal_impressum">
<div class="modal-dialog modal-lg">
<div class="modal-content">
<div class="modal-header">
<div class="float-left">
<div class="headline">
Imprint
</div>
</div>
<div class="float-right close-btn" data-dismiss="modal"><i class="fa fa-times pointer"></i></div>
</div>
<div class="modal-body">
The Linkvertise service is provided to you by:<br><br><span class="test"></span><br><br>Linkvertise GmbH & Co. KG<br>Fraunhoferstraße 3<br>25524 Itzehoe<br>Germany<br><br><br>Register court & Register number:<br>Amtsgericht Pinneberg<br>HRA 8998 PI<br><br>Managing Director: Marc Aurel Winter<br>Tel.: +49 1516 4598793<br>E-Mail: <a href="index.html" class="__cf_email__" data-cfemail="573e393138173b3e393c213225233e24327934383a">[email&#160;protected]</a><br><br>
Use our support chat for quick answers or send us an email:<br><br>
<b>General Inquiries</b><br>
<a href="index.html" class="__cf_email__" data-cfemail="c8a1a6aea788a4a1a6a3beadbabca1bbade6aba7a5">[email&#160;protected]</a><br><br>
<b>Publisher Support</b><br>
<a href="index.html" class="__cf_email__" data-cfemail="8afaffe8e6e3f9e2eff8cae6e3e4e1fceff8fee3f9efa4e9e5e7">[email&#160;protected]</a><br><br>
<b>Partner Support</b><br>
<a href="index.html" class="__cf_email__" data-cfemail="1666776462787364567a7f787d607364627f65733875797b">[email&#160;protected]</a><br><br>
<b>Premium Support</b><br>
<a href="index.html" class="__cf_email__" data-cfemail="7d0d0f18101408103d111413160b180f09140e18531e1210">[email&#160;protected]</a><br><br>
<b>Advertiser Support</b><br>
<a href="index.html" class="__cf_email__" data-cfemail="88e9ecfeedfafce1fbedfac8e4e1e6e3feedfafce1fbeda6ebe7e5">[email&#160;protected]</a><br><br>
<b>Report Abuse</b><br>
<a href="index.html" class="__cf_email__" data-cfemail="2b4a495e584e6b474245405d4e595f42584e05484446">[email&#160;protected]</a><br><br><br>Owner:<br>Marc Winter<br><br>VAT Number:<br>DE34 29 934 55<br><br>Social Media Presence:<br>This imprint also applies to our YouTube presence "Linkvertise", as well as our Twitter profile @Linkvertise.<br><br><span class="test">Liability for content:</span><br><br>As a service provider we are responsible according to § 7 Abs.1 TMG for own contents on these sides according to the general laws. According to §§ 8 to 10 TMG, however, we as a service provider are not obliged to monitor transmitted or stored external information or to investigate circumstances that indicate illegal activity. Obligations to remove or block the use of information under general law remain unaffected. However, liability in this regard is only possible from the moment of knowledge of a specific infringement. Upon notification of appropriate violations by the "Link Report" function, we will remove this content immediately.<br><br><span class="test">Liability for links:</span><br><br>Our offer contains links to external websites of third parties over whose contents we have no influence. Therefore we can not assume any liability for these external contents. The content of the linked pages is always the responsibility of the respective provider or operator of the pages. A permanent content control of the linked pages is not reasonable without concrete indications of an infringement. Upon notification of violations, we will remove such links immediately.<br><br><span class="test">Copyright:</span><br><br>The content and works on these pages created by the site operators are subject to German copyright law. The duplication, processing, distribution and any kind of exploitation outside the limits of copyright require the written consent of the respective author or creator. Downloads and copies of this site are for private, non-commercial use only. As far as the contents on this side were not created by the operator, the copyrights of third parties are considered. Should you still be aware of a copyright infringement, we ask for a note. Upon notification of violations, we will remove such content immediately.<br><br><span class="test">Online Dispute Resolution:</span><br><br>The European Commission provides a platform for online dispute resolution (OS). The platform can be found at https://ec.europa.eu/consumers/odr. Consumers have the opportunity to use this platform to resolve their disputes.<br><br><span class="test">Settlement of consumer disputes:</span><br><br>We are not obligated to participate in a dispute settlement procedure before a consumer arbitration board and will decide on a case-by-case basis individually.<br><br>With best regards<br>Marc Winter
</div>
</div>
</div>
</div>
<div class="modal fade" id="modal_agb">
<div class="modal-dialog modal-lg">
<div class="modal-content">
<div class="modal-header">
<div class="float-left">
<div class="headline">
Terms of service
</div>
</div>
<div class="float-right close-btn" data-dismiss="modal"><i class="fa fa-times pointer"></i></div>
</div>
<div class="modal-body">
<span class="test">1. Scope & Defense clause</span><br><br>(1) For the legal relations between the operator of the site (hereinafter referred to as "Provider") and its customers based on this website, the following general terms and conditions apply exclusively in the respective version at the time of account creation.<br><br>(2) Deviating general terms and conditions of the customer will be rejected.<br><br><span class="test">2. Disclaimer</span><br><br>(1) Claims for damages of the customer are excluded, unless otherwise stated below. The above disclaimer of liability also applies in favor of the legal representatives and vicarious agents of the provider, if the customer claims against them.<br><br>(2) Excluded from the exclusion of liability stated under point 1 are claims for damages due to injury to life, limb and health. Also excluded from the disclaimer is the liability for damages based on an intentional or grossly negligent breach of duty by the provider, its legal representatives or vicarious agents.<br><br><span class="test">3. Choice of law and jurisdiction</span><br><br>(1) The law of the Federal Republic of Germany applies to the contractual relations between the supplier and the customer.<br><br>(2) Jurisdiction for all disputes arising from the contractual relationship between the customer and the provider is the domicile of the provider, if the customer is a merchant, a legal entity under public law or a special fund under public law.<br><br><span class="test">4. External links</span>span><br><br>The website contains so-called "external links" (links) to other websites on whose content the provider of the website has no influence. For this reason, the provider can not assume any liability for this content. For the contents and correctness of the provided information the respective offerer of the linked web page is responsible. Upon notification of an infringement by the "Report link" function, the link will be removed immediately.<br><br><span class="test">5. Severability clause</span><br><br>Should any provision of these Terms and Conditions be ineffective, this shall not affect the validity of the remaining provisions.<br><br><span class="test">6. Claim</span><br><br>The operator reserves the right to block or delete publishers or premium accounts without giving any reason and to modify the existing data.<br>The only payment methods are those that the operator claims.<br><br><span class="test">7. Legal process</span><br><br>The legal process is excluded.<br><br>Addition for Publisher Accounts<br><br><span class="test">Guidelines for payouts:</span><br><br>All users of our website are required to comply with the program policies. Please read this carefully. For policy violations, we reserve the right to suspend links or disable your user account at any time. Exceptions must be expressly approved by Linkvertise. When your account is deactivated, you will no longer be able to participate in the Linkvertise Payout Program.<br><br>Please read carefully our program policies.
</div>
</div>
</div>
</div>
<div class="modal fade" id="auth__password_forgot">
<div class="modal-dialog modal-md">
<div class="modal-content">
<div class="modal-body">
<button type="button" class="close" data-dismiss="modal">&times;</button>
<div class="h3 modal-header">Reset password</div>
<form data-ajax="https://publisher.linkvertise.com/password_forgot" method="POST">
<div class="alert-wrapper"></div>
<div class="form-group">
<label class="control-label" for="email">E-Mail<span class="text-danger">*</span></label>
<input class="form-control" id="email" name="email" placeholder="E-Mail Adresse" autocomplete="off" type="text">
</div>
<hr />
<div class="text-center">
<div class="g-recaptcha d-flex justify-content-center" data-sitekey="6LcEr_UUAAAAAHXt5wx-k9P_m8Z1JY-Ck9Mxrhxo">
</div>
</div>
<hr />
<div class="form-group">
<div class="row">
<div class="col-xs-12 col-md-6 offset-md-3">
<button type="submit" class="btn btn-block btn-success">Reset password</button>
</div>
</div>
</div>
 </form>
</div>
</div>
</div>
</div>
<div class="modal fade" id="modal_success">
<div class="modal-dialog">
<div class="modal-content">
<div class="modal-header">
<button type="button" class="close" data-dismiss="modal"><span>&times;</span></button>
<h4>Erfolgreich</h4>
</div>
<div class="modal-body">
<p id="message"></p>
</div>
<div class="modal-footer">
<button class="btn btn-primary" data-dismiss="modal">Okay</button>
</div>
</div>
</div>
</div>
<div class="modal fade" id="modal_confirm">
<div class="modal-dialog">
<div class="modal-content">
<div class="modal-header">
<button type="button" class="close" data-dismiss="modal"><span>&times;</span></button>
<h4>Bestätigen</h4>
</div>
<div class="modal-body">
<p id="message"></p>
</div>
<div class="modal-footer">
<button class="btn btn-primary" data-dismiss="modal" data-accept="">Ja</button>
<button class="btn btn-default" data-dismiss="modal">Abbrechen</button>
</div>
</div>
</div>
</div>
</div>
<div class="js-cookie-consent cookie-consent">
<span class="cookie-consent__message">
Your experience on this site will be improved by allowing cookies.
</span>
<button class="js-cookie-consent-agree cookie-consent__agree">
Allow cookies
</button>
</div>
<script data-cfasync="false" src="cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>
        window.laravelCookieConsent = (function () {
            const COOKIE_VALUE = 1;
            const COOKIE_DOMAIN = '.linkvertise.com';
            function consentWithCookies() {
                setCookie('laravel_cookie_consent', COOKIE_VALUE, 7300);
                hideCookieDialog();
            }
            function cookieExists(name) {
                return (document.cookie.split('; ').indexOf(name + '=' + COOKIE_VALUE) !== -1);
            }
            function hideCookieDialog() {
                const dialogs = document.getElementsByClassName('js-cookie-consent');
                for (let i = 0; i < dialogs.length; ++i) {
                    dialogs[i].style.display = 'none';
                }
            }
            function setCookie(name, value, expirationInDays) {
                const date = new Date();
                date.setTime(date.getTime() + (expirationInDays * 24 * 60 * 60 * 1000));
                document.cookie = name + '=' + value
                    + ';expires=' + date.toUTCString()
                    + ';domain=' + COOKIE_DOMAIN
                    + ';path=/';
            }
            if (cookieExists('laravel_cookie_consent')) {
                hideCookieDialog();
            }
            const buttons = document.getElementsByClassName('js-cookie-consent-agree');
            for (let i = 0; i < buttons.length; ++i) {
                buttons[i].addEventListener('click', consentWithCookies);
            }
            return {
                consentWithCookies: consentWithCookies,
                hideCookieDialog: hideCookieDialog
            };
        })();
    </script>
<div class="footer">
<div class="container">
<a href="" data-toggle="modal" data-target="#modal_impressum">Contact</a>
<a href="" data-toggle="modal" data-target="#modal_datenschutz">Data protection</a>
<a href="" data-toggle="modal" data-target="#modal_teilnahme">Terms of participation</a>
<a href="" data-toggle="modal" data-target="#modal_programm">Program guidelines</a>
<a href="" data-toggle="modal" data-target="#modal_agb">Terms of service</a>
</div>
</div>
<script src="assets/vendor/tether/js/tether.js"></script>
<script src="ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="bootstrap/4.0.0-alpha.6/js/bootstrap.min.js" ></script> <script src="michalsnik/aos/2.1.1/dist/aos.js"></script>
<script src="assets/linkvertise/vendor/typed/typed.min.js"></script>
<script src="assets/vendor/bootstrap-sweetalerts/sweetalert.min.js"></script>
<script src="1.10.18/js/jquery.dataTables.min.js"></script>
<script src="1.10.18/js/dataTables.bootstrap4.min.js"></script>
<script src="assets/vendor/chartjs/Chart.bundle.js"></script>
<script src="assets/linkvertise/vendor/switchery/switchery.min.js"></script>
<script src="ajax/libs/moment_js/2.24.0/moment.min.js"></script>
<script src="ajax/libs/moment_js/2.24.0/locale/de.js"></script>
<script src="npm/vue_2.6.11/dist/vue.min.js"></script>
<script src="assets/linkvertise/script.js"></script>
<script>
        $(".fade").removeClass("fade");
        $(function () {
            $('[data-toggle="tooltip"]').tooltip()
        });
        AOS.init({
            disable: 'mobile'
        });
    </script>
<script>
        $("*[data-toggle='sidebar']").click(function(e)
        {
            e.preventDefault();
            e.stopPropagation();
            $(".sidebar").toggleClass("show");
        });
    </script>
<script>
        $(".sidebar a[data-toggle='tab']").click(function(e)
        {
            $(".sidebar").removeClass("show");
        });
    </script>
<script>
        $("*[data-datatable]").each(function (e) {
            var columns = [];
            $(this).find("*[data-column]").each(function (e) {
                var data =
                    {
                        data: $(this).data('column'),
                        name: $(this).data('column'),
                        "searchable": $(this).data('searchable') !== undefined ? $(this).data('searchable') : true,
                        "orderable": $(this).data('orderable') !== undefined ? $(this).data('orderable') : true
                    };
                columns.push(data);
            });
            var order = $(this).data('default-order') ? $(this).data('default-order') : [[0, 'asc']];
            var paging = $(this).data('pagination') !== undefined ? $(this).data('pagination') : true;
            $(this).DataTable({
                "iDisplayLength": 10,
                "serverSide": paging,
                "order": order,
                "autoWidth": false,
                "paging": paging,
                searching: false,
                processing: paging,
                "bProcessing": true,
                "columns": columns,
                "ajax": {
                    method: "post",
                    url: $(this).data("datatable"),
                    xhrFields: {
                        withCredentials: true
                    }
                },
                            });
        });
    </script>
<script>
        function onSubmit(token) {
            $("#register_form").trigger("submit");
        }
    </script>
<div class="loading-overlay">
<div class="loader" style="display: none;">
<img src="assets/loading2.svg" alt="" />
</div>
</div>
<script>
        $(document).ready(function()
        {
            $("#campaign-input-text").val("");
            new Typed('#campaign-input-text',
                {
                    strings: ["https://awesome-page.de?refer=10323", "https://www.youtube.com/watch?v=RBfOoVrGvq4", "Insert your URL and earn money!^1000", "https://"],
                    typeSpeed: 40
                });
        });
        $(document).ready(function()
        {
            $("#campaign-input-text").val("");
            new Typed('#campaign-input-text-sm',
                {
                    strings: ["https://awesome-page.de?refer=10323", "https://www.youtube.com/watch?v=RBfOoVrGvq4", "Insert your URL and earn money!^1000", "https://"],
                    typeSpeed: 40
                });
        });
    </script>
<script>
        $(".sidebar *").on("show.bs.tab", function()
        {
            setTimeout(() => $(window).trigger("resize"), 1e3);
        });
    </script>
<script type="text/javascript" src="script/ga.js" async></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=AW-963309080"></script>
<script>
        window.dataLayer = window.dataLayer || [];
        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());
        gtag('config', 'AW-963309080');
    </script>
<script>
        $(".notification-bell").click(function () {
            $(".notification-dropdown").toggleClass("open");
        });
    </script>
<script>
        window.swal_title = "Success";
        window.days = "Days";
        window.swal_yes = "Yes";
        window.swal_no = "No";
        window.swal_confirm = "Confirm";
    </script>

/*!
 * Cropper.js v1.5.12
 * https://fengyuanchen.github.io/cropperjs
 *
 * Copyright 2015-present Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2021-06-12T08:00:17.411Z
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Cropper = factory());
}(this, (function () { 'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);

      if (enumerableOnly) {
        symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }

      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';
  var WINDOW = IS_BROWSER ? window : {};
  var IS_TOUCH_DEVICE = IS_BROWSER && WINDOW.document.documentElement ? 'ontouchstart' in WINDOW.document.documentElement : false;
  var HAS_POINTER_EVENT = IS_BROWSER ? 'PointerEvent' in WINDOW : false;
  var NAMESPACE = 'cropper'; // Actions

  var ACTION_ALL = 'all';
  var ACTION_CROP = 'crop';
  var ACTION_MOVE = 'move';
  var ACTION_ZOOM = 'zoom';
  var ACTION_EAST = 'e';
  var ACTION_WEST = 'w';
  var ACTION_SOUTH = 's';
  var ACTION_NORTH = 'n';
  var ACTION_NORTH_EAST = 'ne';
  var ACTION_NORTH_WEST = 'nw';
  var ACTION_SOUTH_EAST = 'se';
  var ACTION_SOUTH_WEST = 'sw'; // Classes

  var CLASS_CROP = "".concat(NAMESPACE, "-crop");
  var CLASS_DISABLED = "".concat(NAMESPACE, "-disabled");
  var CLASS_HIDDEN = "".concat(NAMESPACE, "-hidden");
  var CLASS_HIDE = "".concat(NAMESPACE, "-hide");
  var CLASS_INVISIBLE = "".concat(NAMESPACE, "-invisible");
  var CLASS_MODAL = "".concat(NAMESPACE, "-modal");
  var CLASS_MOVE = "".concat(NAMESPACE, "-move"); // Data keys

  var DATA_ACTION = "".concat(NAMESPACE, "Action");
  var DATA_PREVIEW = "".concat(NAMESPACE, "Preview"); // Drag modes

  var DRAG_MODE_CROP = 'crop';
  var DRAG_MODE_MOVE = 'move';
  var DRAG_MODE_NONE = 'none'; // Events

  var EVENT_CROP = 'crop';
  var EVENT_CROP_END = 'cropend';
  var EVENT_CROP_MOVE = 'cropmove';
  var EVENT_CROP_START = 'cropstart';
  var EVENT_DBLCLICK = 'dblclick';
  var EVENT_TOUCH_START = IS_TOUCH_DEVICE ? 'touchstart' : 'mousedown';
  var EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? 'touchmove' : 'mousemove';
  var EVENT_TOUCH_END = IS_TOUCH_DEVICE ? 'touchend touchcancel' : 'mouseup';
  var EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? 'pointerdown' : EVENT_TOUCH_START;
  var EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? 'pointermove' : EVENT_TOUCH_MOVE;
  var EVENT_POINTER_UP = HAS_POINTER_EVENT ? 'pointerup pointercancel' : EVENT_TOUCH_END;
  var EVENT_READY = 'ready';
  var EVENT_RESIZE = 'resize';
  var EVENT_WHEEL = 'wheel';
  var EVENT_ZOOM = 'zoom'; // Mime types

  var MIME_TYPE_JPEG = 'image/jpeg'; // RegExps

  var REGEXP_ACTIONS = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/;
  var REGEXP_DATA_URL = /^data:/;
  var REGEXP_DATA_URL_JPEG = /^data:image\/jpeg;base64,/;
  var REGEXP_TAG_NAME = /^img|canvas$/i; // Misc
  // Inspired by the default width and height of a canvas element.

  var MIN_CONTAINER_WIDTH = 200;
  var MIN_CONTAINER_HEIGHT = 100;

  var DEFAULTS = {
    // Define the view mode of the cropper
    viewMode: 0,
    // 0, 1, 2, 3
    // Define the dragging mode of the cropper
    dragMode: DRAG_MODE_CROP,
    // 'crop', 'move' or 'none'
    // Define the initial aspect ratio of the crop box
    initialAspectRatio: NaN,
    // Define the aspect ratio of the crop box
    aspectRatio: NaN,
    // An object with the previous cropping result data
    data: null,
    // A selector for adding extra containers to preview
    preview: '',
    // Re-render the cropper when resize the window
    responsive: true,
    // Restore the cropped area after resize the window
    restore: true,
    // Check if the current image is a cross-origin image
    checkCrossOrigin: true,
    // Check the current image's Exif Orientation information
    checkOrientation: true,
    // Show the black modal
    modal: true,
    // Show the dashed lines for guiding
    guides: true,
    // Show the center indicator for guiding
    center: true,
    // Show the white modal to highlight the crop box
    highlight: true,
    // Show the grid background
    background: true,
    // Enable to crop the image automatically when initialize
    autoCrop: true,
    // Define the percentage of automatic cropping area when initializes
    autoCropArea: 0.8,
    // Enable to move the image
    movable: true,
    // Enable to rotate the image
    rotatable: true,
    // Enable to scale the image
    scalable: true,
    // Enable to zoom the image
    zoomable: true,
    // Enable to zoom the image by dragging touch
    zoomOnTouch: true,
    // Enable to zoom the image by wheeling mouse
    zoomOnWheel: true,
    // Define zoom ratio when zoom the image by wheeling mouse
    wheelZoomRatio: 0.1,
    // Enable to move the crop box
    cropBoxMovable: true,
    // Enable to resize the crop box
    cropBoxResizable: true,
    // Toggle drag mode between "crop" and "move" when click twice on the cropper
    toggleDragModeOnDblclick: true,
    // Size limitation
    minCanvasWidth: 0,
    minCanvasHeight: 0,
    minCropBoxWidth: 0,
    minCropBoxHeight: 0,
    minContainerWidth: MIN_CONTAINER_WIDTH,
    minContainerHeight: MIN_CONTAINER_HEIGHT,
    // Shortcuts of events
    ready: null,
    cropstart: null,
    cropmove: null,
    cropend: null,
    crop: null,
    zoom: null
  };

  var TEMPLATE = '<div class="cropper-container" touch-action="none">' + '<div class="cropper-wrap-box">' + '<div class="cropper-canvas"></div>' + '</div>' + '<div class="cropper-drag-box"></div>' + '<div class="cropper-crop-box">' + '<span class="cropper-view-box"></span>' + '<span class="cropper-dashed dashed-h"></span>' + '<span class="cropper-dashed dashed-v"></span>' + '<span class="cropper-center"></span>' + '<span class="cropper-face"></span>' + '<span class="cropper-line line-e" data-cropper-action="e"></span>' + '<span class="cropper-line line-n" data-cropper-action="n"></span>' + '<span class="cropper-line line-w" data-cropper-action="w"></span>' + '<span class="cropper-line line-s" data-cropper-action="s"></span>' + '<span class="cropper-point point-e" data-cropper-action="e"></span>' + '<span class="cropper-point point-n" data-cropper-action="n"></span>' + '<span class="cropper-point point-w" data-cropper-action="w"></span>' + '<span class="cropper-point point-s" data-cropper-action="s"></span>' + '<span class="cropper-point point-ne" data-cropper-action="ne"></span>' + '<span class="cropper-point point-nw" data-cropper-action="nw"></span>' + '<span class="cropper-point point-sw" data-cropper-action="sw"></span>' + '<span class="cropper-point point-se" data-cropper-action="se"></span>' + '</div>' + '</div>';

  /**
   * Check if the given value is not a number.
   */

  var isNaN = Number.isNaN || WINDOW.isNaN;
  /**
   * Check if the given value is a number.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is a number, else `false`.
   */

  function isNumber(value) {
    return typeof value === 'number' && !isNaN(value);
  }
  /**
   * Check if the given value is a positive number.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is a positive number, else `false`.
   */

  var isPositiveNumber = function isPositiveNumber(value) {
    return value > 0 && value < Infinity;
  };
  /**
   * Check if the given value is undefined.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is undefined, else `false`.
   */

  function isUndefined(value) {
    return typeof value === 'undefined';
  }
  /**
   * Check if the given value is an object.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is an object, else `false`.
   */

  function isObject(value) {
    return _typeof(value) === 'object' && value !== null;
  }
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  /**
   * Check if the given value is a plain object.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is a plain object, else `false`.
   */

  function isPlainObject(value) {
    if (!isObject(value)) {
      return false;
    }

    try {
      var _constructor = value.constructor;
      var prototype = _constructor.prototype;
      return _constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');
    } catch (error) {
      return false;
    }
  }
  /**
   * Check if the given value is a function.
   * @param {*} value - The value to check.
   * @returns {boolean} Returns `true` if the given value is a function, else `false`.
   */

  function isFunction(value) {
    return typeof value === 'function';
  }
  var slice = Array.prototype.slice;
  /**
   * Convert array-like or iterable object to an array.
   * @param {*} value - The value to convert.
   * @returns {Array} Returns a new array.
   */

  function toArray(value) {
    return Array.from ? Array.from(value) : slice.call(value);
  }
  /**
   * Iterate the given data.
   * @param {*} data - The data to iterate.
   * @param {Function} callback - The process function for each element.
   * @returns {*} The original data.
   */

  function forEach(data, callback) {
    if (data && isFunction(callback)) {
      if (Array.isArray(data) || isNumber(data.length)
      /* array-like */
      ) {
          toArray(data).forEach(function (value, key) {
            callback.call(data, value, key, data);
          });
        } else if (isObject(data)) {
        Object.keys(data).forEach(function (key) {
          callback.call(data, data[key], key, data);
        });
      }
    }

    return data;
  }
  /**
   * Extend the given object.
   * @param {*} target - The target object to extend.
   * @param {*} args - The rest objects for merging to the target object.
   * @returns {Object} The extended object.
   */

  var assign = Object.assign || function assign(target) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    if (isObject(target) && args.length > 0) {
      args.forEach(function (arg) {
        if (isObject(arg)) {
          Object.keys(arg).forEach(function (key) {
            target[key] = arg[key];
          });
        }
      });
    }

    return target;
  };
  var REGEXP_DECIMALS = /\.\d*(?:0|9){12}\d*$/;
  /**
   * Normalize decimal number.
   * Check out {@link https://0.30000000000000004.com/}
   * @param {number} value - The value to normalize.
   * @param {number} [times=100000000000] - The times for normalizing.
   * @returns {number} Returns the normalized number.
   */

  function normalizeDecimalNumber(value) {
    var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100000000000;
    return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;
  }
  var REGEXP_SUFFIX = /^width|height|left|top|marginLeft|marginTop$/;
  /**
   * Apply styles to the given element.
   * @param {Element} element - The target element.
   * @param {Object} styles - The styles for applying.
   */

  function setStyle(element, styles) {
    var style = element.style;
    forEach(styles, function (value, property) {
      if (REGEXP_SUFFIX.test(property) && isNumber(value)) {
        value = "".concat(value, "px");
      }

      style[property] = value;
    });
  }
  /**
   * Check if the given element has a special class.
   * @param {Element} element - The element to check.
   * @param {string} value - The class to search.
   * @returns {boolean} Returns `true` if the special class was found.
   */

  function hasClass(element, value) {
    return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;
  }
  /**
   * Add classes to the given element.
   * @param {Element} element - The target element.
   * @param {string} value - The classes to be added.
   */

  function addClass(element, value) {
    if (!value) {
      return;
    }

    if (isNumber(element.length)) {
      forEach(element, function (elem) {
        addClass(elem, value);
      });
      return;
    }

    if (element.classList) {
      element.classList.add(value);
      return;
    }

    var className = element.className.trim();

    if (!className) {
      element.className = value;
    } else if (className.indexOf(value) < 0) {
      element.className = "".concat(className, " ").concat(value);
    }
  }
  /**
   * Remove classes from the given element.
   * @param {Element} element - The target element.
   * @param {string} value - The classes to be removed.
   */

  function removeClass(element, value) {
    if (!value) {
      return;
    }

    if (isNumber(element.length)) {
      forEach(element, function (elem) {
        removeClass(elem, value);
      });
      return;
    }

    if (element.classList) {
      element.classList.remove(value);
      return;
    }

    if (element.className.indexOf(value) >= 0) {
      element.className = element.className.replace(value, '');
    }
  }
  /**
   * Add or remove classes from the given element.
   * @param {Element} element - The target element.
   * @param {string} value - The classes to be toggled.
   * @param {boolean} added - Add only.
   */

  function toggleClass(element, value, added) {
    if (!value) {
      return;
    }

    if (isNumber(element.length)) {
      forEach(element, function (elem) {
        toggleClass(elem, value, added);
      });
      return;
    } // IE10-11 doesn't support the second parameter of `classList.toggle`


    if (added) {
      addClass(element, value);
    } else {
      removeClass(element, value);
    }
  }
  var REGEXP_CAMEL_CASE = /([a-z\d])([A-Z])/g;
  /**
   * Transform the given string from camelCase to kebab-case
   * @param {string} value - The value to transform.
   * @returns {string} The transformed value.
   */

  function toParamCase(value) {
    return value.replace(REGEXP_CAMEL_CASE, '$1-$2').toLowerCase();
  }
  /**
   * Get data from the given element.
   * @param {Element} element - The target element.
   * @param {string} name - The data key to get.
   * @returns {string} The data value.
   */

  function getData(element, name) {
    if (isObject(element[name])) {
      return element[name];
    }

    if (element.dataset) {
      return element.dataset[name];
    }

    return element.getAttribute("data-".concat(toParamCase(name)));
  }
  /**
   * Set data to the given element.
   * @param {Element} element - The target element.
   * @param {string} name - The data key to set.
   * @param {string} data - The data value.
   */

  function setData(element, name, data) {
    if (isObject(data)) {
      element[name] = data;
    } else if (element.dataset) {
      element.dataset[name] = data;
    } else {
      element.setAttribute("data-".concat(toParamCase(name)), data);
    }
  }
  /**
   * Remove data from the given element.
   * @param {Element} element - The target element.
   * @param {string} name - The data key to remove.
   */

  function removeData(element, name) {
    if (isObject(element[name])) {
      try {
        delete element[name];
      } catch (error) {
        element[name] = undefined;
      }
    } else if (element.dataset) {
      // #128 Safari not allows to delete dataset property
      try {
        delete element.dataset[name];
      } catch (error) {
        element.dataset[name] = undefined;
      }
    } else {
      element.removeAttribute("data-".concat(toParamCase(name)));
    }
  }
  var REGEXP_SPACES = /\s\s*/;

  var onceSupported = function () {
    var supported = false;

    if (IS_BROWSER) {
      var once = false;

      var listener = function listener() {};

      var options = Object.defineProperty({}, 'once', {
        get: function get() {
          supported = true;
          return once;
        },

        /**
         * This setter can fix a `TypeError` in strict mode
         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}
         * @param {boolean} value - The value to set
         */
        set: function set(value) {
          once = value;
        }
      });
      WINDOW.addEventListener('test', listener, options);
      WINDOW.removeEventListener('test', listener, options);
    }

    return supported;
  }();
  /**
   * Remove event listener from the target element.
   * @param {Element} element - The event target.
   * @param {string} type - The event type(s).
   * @param {Function} listener - The event listener.
   * @param {Object} options - The event options.
   */


  function removeListener(element, type, listener) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var handler = listener;
    type.trim().split(REGEXP_SPACES).forEach(function (event) {
      if (!onceSupported) {
        var listeners = element.listeners;

        if (listeners && listeners[event] && listeners[event][listener]) {
          handler = listeners[event][listener];
          delete listeners[event][listener];

          if (Object.keys(listeners[event]).length === 0) {
            delete listeners[event];
          }

          if (Object.keys(listeners).length === 0) {
            delete element.listeners;
          }
        }
      }

      element.removeEventListener(event, handler, options);
    });
  }
  /**
   * Add event listener to the target element.
   * @param {Element} element - The event target.
   * @param {string} type - The event type(s).
   * @param {Function} listener - The event listener.
   * @param {Object} options - The event options.
   */

  function addListener(element, type, listener) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var _handler = listener;
    type.trim().split(REGEXP_SPACES).forEach(function (event) {
      if (options.once && !onceSupported) {
        var _element$listeners = element.listeners,
            listeners = _element$listeners === void 0 ? {} : _element$listeners;

        _handler = function handler() {
          delete listeners[event][listener];
          element.removeEventListener(event, _handler, options);

          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          listener.apply(element, args);
        };

        if (!listeners[event]) {
          listeners[event] = {};
        }

        if (listeners[event][listener]) {
          element.removeEventListener(event, listeners[event][listener], options);
        }

        listeners[event][listener] = _handler;
        element.listeners = listeners;
      }

      element.addEventListener(event, _handler, options);
    });
  }
  /**
   * Dispatch event on the target element.
   * @param {Element} element - The event target.
   * @param {string} type - The event type(s).
   * @param {Object} data - The additional event data.
   * @returns {boolean} Indicate if the event is default prevented or not.
   */

  function dispatchEvent(element, type, data) {
    var event; // Event and CustomEvent on IE9-11 are global objects, not constructors

    if (isFunction(Event) && isFunction(CustomEvent)) {
      event = new CustomEvent(type, {
        detail: data,
        bubbles: true,
        cancelable: true
      });
    } else {
      event = document.createEvent('CustomEvent');
      event.initCustomEvent(type, true, true, data);
    }

    return element.dispatchEvent(event);
  }
  /**
   * Get the offset base on the document.
   * @param {Element} element - The target element.
   * @returns {Object} The offset data.
   */

  function getOffset(element) {
    var box = element.getBoundingClientRect();
    return {
      left: box.left + (window.pageXOffset - document.documentElement.clientLeft),
      top: box.top + (window.pageYOffset - document.documentElement.clientTop)
    };
  }
  var location = WINDOW.location;
  var REGEXP_ORIGINS = /^(\w+:)\/\/([^:/?#]*):?(\d*)/i;
  /**
   * Check if the given URL is a cross origin URL.
   * @param {string} url - The target URL.
   * @returns {boolean} Returns `true` if the given URL is a cross origin URL, else `false`.
   */

  function isCrossOriginURL(url) {
    var parts = url.match(REGEXP_ORIGINS);
    return parts !== null && (parts[1] !== location.protocol || parts[2] !== location.hostname || parts[3] !== location.port);
  }
  /**
   * Add timestamp to the given URL.
   * @param {string} url - The target URL.
   * @returns {string} The result URL.
   */

  function addTimestamp(url) {
    var timestamp = "timestamp=".concat(new Date().getTime());
    return url + (url.indexOf('?') === -1 ? '?' : '&') + timestamp;
  }
  /**
   * Get transforms base on the given object.
   * @param {Object} obj - The target object.
   * @returns {string} A string contains transform values.
   */

  function getTransforms(_ref) {
    var rotate = _ref.rotate,
        scaleX = _ref.scaleX,
        scaleY = _ref.scaleY,
        translateX = _ref.translateX,
        translateY = _ref.translateY;
    var values = [];

    if (isNumber(translateX) && translateX !== 0) {
      values.push("translateX(".concat(translateX, "px)"));
    }

    if (isNumber(translateY) && translateY !== 0) {
      values.push("translateY(".concat(translateY, "px)"));
    } // Rotate should come first before scale to match orientation transform


    if (isNumber(rotate) && rotate !== 0) {
      values.push("rotate(".concat(rotate, "deg)"));
    }

    if (isNumber(scaleX) && scaleX !== 1) {
      values.push("scaleX(".concat(scaleX, ")"));
    }

    if (isNumber(scaleY) && scaleY !== 1) {
      values.push("scaleY(".concat(scaleY, ")"));
    }

    var transform = values.length ? values.join(' ') : 'none';
    return {
      WebkitTransform: transform,
      msTransform: transform,
      transform: transform
    };
  }
  /**
   * Get the max ratio of a group of pointers.
   * @param {string} pointers - The target pointers.
   * @returns {number} The result ratio.
   */

  function getMaxZoomRatio(pointers) {
    var pointers2 = _objectSpread2({}, pointers);

    var maxRatio = 0;
    forEach(pointers, function (pointer, pointerId) {
      delete pointers2[pointerId];
      forEach(pointers2, function (pointer2) {
        var x1 = Math.abs(pointer.startX - pointer2.startX);
        var y1 = Math.abs(pointer.startY - pointer2.startY);
        var x2 = Math.abs(pointer.endX - pointer2.endX);
        var y2 = Math.abs(pointer.endY - pointer2.endY);
        var z1 = Math.sqrt(x1 * x1 + y1 * y1);
        var z2 = Math.sqrt(x2 * x2 + y2 * y2);
        var ratio = (z2 - z1) / z1;

        if (Math.abs(ratio) > Math.abs(maxRatio)) {
          maxRatio = ratio;
        }
      });
    });
    return maxRatio;
  }
  /**
   * Get a pointer from an event object.
   * @param {Object} event - The target event object.
   * @param {boolean} endOnly - Indicates if only returns the end point coordinate or not.
   * @returns {Object} The result pointer contains start and/or end point coordinates.
   */

  function getPointer(_ref2, endOnly) {
    var pageX = _ref2.pageX,
        pageY = _ref2.pageY;
    var end = {
      endX: pageX,
      endY: pageY
    };
    return endOnly ? end : _objectSpread2({
      startX: pageX,
      startY: pageY
    }, end);
  }
  /**
   * Get the center point coordinate of a group of pointers.
   * @param {Object} pointers - The target pointers.
   * @returns {Object} The center point coordinate.
   */

  function getPointersCenter(pointers) {
    var pageX = 0;
    var pageY = 0;
    var count = 0;
    forEach(pointers, function (_ref3) {
      var startX = _ref3.startX,
          startY = _ref3.startY;
      pageX += startX;
      pageY += startY;
      count += 1;
    });
    pageX /= count;
    pageY /= count;
    return {
      pageX: pageX,
      pageY: pageY
    };
  }
  /**
   * Get the max sizes in a rectangle under the given aspect ratio.
   * @param {Object} data - The original sizes.
   * @param {string} [type='contain'] - The adjust type.
   * @returns {Object} The result sizes.
   */

  function getAdjustedSizes(_ref4) // or 'cover'
  {
    var aspectRatio = _ref4.aspectRatio,
        height = _ref4.height,
        width = _ref4.width;
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'contain';
    var isValidWidth = isPositiveNumber(width);
    var isValidHeight = isPositiveNumber(height);

    if (isValidWidth && isValidHeight) {
      var adjustedWidth = height * aspectRatio;

      if (type === 'contain' && adjustedWidth > width || type === 'cover' && adjustedWidth < width) {
        height = width / aspectRatio;
      } else {
        width = height * aspectRatio;
      }
    } else if (isValidWidth) {
      height = width / aspectRatio;
    } else if (isValidHeight) {
      width = height * aspectRatio;
    }

    return {
      width: width,
      height: height
    };
  }
  /**
   * Get the new sizes of a rectangle after rotated.
   * @param {Object} data - The original sizes.
   * @returns {Object} The result sizes.
   */

  function getRotatedSizes(_ref5) {
    var width = _ref5.width,
        height = _ref5.height,
        degree = _ref5.degree;
    degree = Math.abs(degree) % 180;

    if (degree === 90) {
      return {
        width: height,
        height: width
      };
    }

    var arc = degree % 90 * Math.PI / 180;
    var sinArc = Math.sin(arc);
    var cosArc = Math.cos(arc);
    var newWidth = width * cosArc + height * sinArc;
    var newHeight = width * sinArc + height * cosArc;
    return degree > 90 ? {
      width: newHeight,
      height: newWidth
    } : {
      width: newWidth,
      height: newHeight
    };
  }
  /**
   * Get a canvas which drew the given image.
   * @param {HTMLImageElement} image - The image for drawing.
   * @param {Object} imageData - The image data.
   * @param {Object} canvasData - The canvas data.
   * @param {Object} options - The options.
   * @returns {HTMLCanvasElement} The result canvas.
   */

  function getSourceCanvas(image, _ref6, _ref7, _ref8) {
    var imageAspectRatio = _ref6.aspectRatio,
        imageNaturalWidth = _ref6.naturalWidth,
        imageNaturalHeight = _ref6.naturalHeight,
        _ref6$rotate = _ref6.rotate,
        rotate = _ref6$rotate === void 0 ? 0 : _ref6$rotate,
        _ref6$scaleX = _ref6.scaleX,
        scaleX = _ref6$scaleX === void 0 ? 1 : _ref6$scaleX,
        _ref6$scaleY = _ref6.scaleY,
        scaleY = _ref6$scaleY === void 0 ? 1 : _ref6$scaleY;
    var aspectRatio = _ref7.aspectRatio,
        naturalWidth = _ref7.naturalWidth,
        naturalHeight = _ref7.naturalHeight;
    var _ref8$fillColor = _ref8.fillColor,
        fillColor = _ref8$fillColor === void 0 ? 'transparent' : _ref8$fillColor,
        _ref8$imageSmoothingE = _ref8.imageSmoothingEnabled,
        imageSmoothingEnabled = _ref8$imageSmoothingE === void 0 ? true : _ref8$imageSmoothingE,
        _ref8$imageSmoothingQ = _ref8.imageSmoothingQuality,
        imageSmoothingQuality = _ref8$imageSmoothingQ === void 0 ? 'low' : _ref8$imageSmoothingQ,
        _ref8$maxWidth = _ref8.maxWidth,
        maxWidth = _ref8$maxWidth === void 0 ? Infinity : _ref8$maxWidth,
        _ref8$maxHeight = _ref8.maxHeight,
        maxHeight = _ref8$maxHeight === void 0 ? Infinity : _ref8$maxHeight,
        _ref8$minWidth = _ref8.minWidth,
        minWidth = _ref8$minWidth === void 0 ? 0 : _ref8$minWidth,
        _ref8$minHeight = _ref8.minHeight,
        minHeight = _ref8$minHeight === void 0 ? 0 : _ref8$minHeight;
    var canvas = document.createElement('canvas');
    var context = canvas.getContext('2d');
    var maxSizes = getAdjustedSizes({
      aspectRatio: aspectRatio,
      width: maxWidth,
      height: maxHeight
    });
    var minSizes = getAdjustedSizes({
      aspectRatio: aspectRatio,
      width: minWidth,
      height: minHeight
    }, 'cover');
    var width = Math.min(maxSizes.width, Math.max(minSizes.width, naturalWidth));
    var height = Math.min(maxSizes.height, Math.max(minSizes.height, naturalHeight)); // Note: should always use image's natural sizes for drawing as
    // imageData.naturalWidth === canvasData.naturalHeight when rotate % 180 === 90

    var destMaxSizes = getAdjustedSizes({
      aspectRatio: imageAspectRatio,
      width: maxWidth,
      height: maxHeight
    });
    var destMinSizes = getAdjustedSizes({
      aspectRatio: imageAspectRatio,
      width: minWidth,
      height: minHeight
    }, 'cover');
    var destWidth = Math.min(destMaxSizes.width, Math.max(destMinSizes.width, imageNaturalWidth));
    var destHeight = Math.min(destMaxSizes.height, Math.max(destMinSizes.height, imageNaturalHeight));
    var params = [-destWidth / 2, -destHeight / 2, destWidth, destHeight];
    canvas.width = normalizeDecimalNumber(width);
    canvas.height = normalizeDecimalNumber(height);
    context.fillStyle = fillColor;
    context.fillRect(0, 0, width, height);
    context.save();
    context.translate(width / 2, height / 2);
    context.rotate(rotate * Math.PI / 180);
    context.scale(scaleX, scaleY);
    context.imageSmoothingEnabled = imageSmoothingEnabled;
    context.imageSmoothingQuality = imageSmoothingQuality;
    context.drawImage.apply(context, [image].concat(_toConsumableArray(params.map(function (param) {
      return Math.floor(normalizeDecimalNumber(param));
    }))));
    context.restore();
    return canvas;
  }
  var fromCharCode = String.fromCharCode;
  /**
   * Get string from char code in data view.
   * @param {DataView} dataView - The data view for read.
   * @param {number} start - The start index.
   * @param {number} length - The read length.
   * @returns {string} The read result.
   */

  function getStringFromCharCode(dataView, start, length) {
    var str = '';
    length += start;

    for (var i = start; i < length; i += 1) {
      str += fromCharCode(dataView.getUint8(i));
    }

    return str;
  }
  var REGEXP_DATA_URL_HEAD = /^data:.*,/;
  /**
   * Transform Data URL to array buffer.
   * @param {string} dataURL - The Data URL to transform.
   * @returns {ArrayBuffer} The result array buffer.
   */

  function dataURLToArrayBuffer(dataURL) {
    var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, '');
    var binary = atob(base64);
    var arrayBuffer = new ArrayBuffer(binary.length);
    var uint8 = new Uint8Array(arrayBuffer);
    forEach(uint8, function (value, i) {
      uint8[i] = binary.charCodeAt(i);
    });
    return arrayBuffer;
  }
  /**
   * Transform array buffer to Data URL.
   * @param {ArrayBuffer} arrayBuffer - The array buffer to transform.
   * @param {string} mimeType - The mime type of the Data URL.
   * @returns {string} The result Data URL.
   */

  function arrayBufferToDataURL(arrayBuffer, mimeType) {
    var chunks = []; // Chunk Typed Array for better performance (#435)

    var chunkSize = 8192;
    var uint8 = new Uint8Array(arrayBuffer);

    while (uint8.length > 0) {
      // XXX: Babel's `toConsumableArray` helper will throw error in IE or Safari 9
      // eslint-disable-next-line prefer-spread
      chunks.push(fromCharCode.apply(null, toArray(uint8.subarray(0, chunkSize))));
      uint8 = uint8.subarray(chunkSize);
    }

    return "data:".concat(mimeType, ";base64,").concat(btoa(chunks.join('')));
  }
  /**
   * Get orientation value from given array buffer.
   * @param {ArrayBuffer} arrayBuffer - The array buffer to read.
   * @returns {number} The read orientation value.
   */

  function resetAndGetOrientation(arrayBuffer) {
    var dataView = new DataView(arrayBuffer);
    var orientation; // Ignores range error when the image does not have correct Exif information

    try {
      var littleEndian;
      var app1Start;
      var ifdStart; // Only handle JPEG image (start by 0xFFD8)

      if (dataView.getUint8(0) === 0xFF && dataView.getUint8(1) === 0xD8) {
        var length = dataView.byteLength;
        var offset = 2;

        while (offset + 1 < length) {
          if (dataView.getUint8(offset) === 0xFF && dataView.getUint8(offset + 1) === 0xE1) {
            app1Start = offset;
            break;
          }

          offset += 1;
        }
      }

      if (app1Start) {
        var exifIDCode = app1Start + 4;
        var tiffOffset = app1Start + 10;

        if (getStringFromCharCode(dataView, exifIDCode, 4) === 'Exif') {
          var endianness = dataView.getUint16(tiffOffset);
          littleEndian = endianness === 0x4949;

          if (littleEndian || endianness === 0x4D4D
          /* bigEndian */
          ) {
              if (dataView.getUint16(tiffOffset + 2, littleEndian) === 0x002A) {
                var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);

                if (firstIFDOffset >= 0x00000008) {
                  ifdStart = tiffOffset + firstIFDOffset;
                }
              }
            }
        }
      }

      if (ifdStart) {
        var _length = dataView.getUint16(ifdStart, littleEndian);

        var _offset;

        var i;

        for (i = 0; i < _length; i += 1) {
          _offset = ifdStart + i * 12 + 2;

          if (dataView.getUint16(_offset, littleEndian) === 0x0112
          /* Orientation */
          ) {
              // 8 is the offset of the current tag's value
              _offset += 8; // Get the original orientation value

              orientation = dataView.getUint16(_offset, littleEndian); // Override the orientation with its default value

              dataView.setUint16(_offset, 1, littleEndian);
              break;
            }
        }
      }
    } catch (error) {
      orientation = 1;
    }

    return orientation;
  }
  /**
   * Parse Exif Orientation value.
   * @param {number} orientation - The orientation to parse.
   * @returns {Object} The parsed result.
   */

  function parseOrientation(orientation) {
    var rotate = 0;
    var scaleX = 1;
    var scaleY = 1;

    switch (orientation) {
      // Flip horizontal
      case 2:
        scaleX = -1;
        break;
      // Rotate left 180°

      case 3:
        rotate = -180;
        break;
      // Flip vertical

      case 4:
        scaleY = -1;
        break;
      // Flip vertical and rotate right 90°

      case 5:
        rotate = 90;
        scaleY = -1;
        break;
      // Rotate right 90°

      case 6:
        rotate = 90;
        break;
      // Flip horizontal and rotate right 90°

      case 7:
        rotate = 90;
        scaleX = -1;
        break;
      // Rotate left 90°

      case 8:
        rotate = -90;
        break;
    }

    return {
      rotate: rotate,
      scaleX: scaleX,
      scaleY: scaleY
    };
  }

  var render = {
    render: function render() {
      this.initContainer();
      this.initCanvas();
      this.initCropBox();
      this.renderCanvas();

      if (this.cropped) {
        this.renderCropBox();
      }
    },
    initContainer: function initContainer() {
      var element = this.element,
          options = this.options,
          container = this.container,
          cropper = this.cropper;
      var minWidth = Number(options.minContainerWidth);
      var minHeight = Number(options.minContainerHeight);
      addClass(cropper, CLASS_HIDDEN);
      removeClass(element, CLASS_HIDDEN);
      var containerData = {
        width: Math.max(container.offsetWidth, minWidth >= 0 ? minWidth : MIN_CONTAINER_WIDTH),
        height: Math.max(container.offsetHeight, minHeight >= 0 ? minHeight : MIN_CONTAINER_HEIGHT)
      };
      this.containerData = containerData;
      setStyle(cropper, {
        width: containerData.width,
        height: containerData.height
      });
      addClass(element, CLASS_HIDDEN);
      removeClass(cropper, CLASS_HIDDEN);
    },
    // Canvas (image wrapper)
    initCanvas: function initCanvas() {
      var containerData = this.containerData,
          imageData = this.imageData;
      var viewMode = this.options.viewMode;
      var rotated = Math.abs(imageData.rotate) % 180 === 90;
      var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;
      var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;
      var aspectRatio = naturalWidth / naturalHeight;
      var canvasWidth = containerData.width;
      var canvasHeight = containerData.height;

      if (containerData.height * aspectRatio > containerData.width) {
        if (viewMode === 3) {
          canvasWidth = containerData.height * aspectRatio;
        } else {
          canvasHeight = containerData.width / aspectRatio;
        }
      } else if (viewMode === 3) {
        canvasHeight = containerData.width / aspectRatio;
      } else {
        canvasWidth = containerData.height * aspectRatio;
      }

      var canvasData = {
        aspectRatio: aspectRatio,
        naturalWidth: naturalWidth,
        naturalHeight: naturalHeight,
        width: canvasWidth,
        height: canvasHeight
      };
      this.canvasData = canvasData;
      this.limited = viewMode === 1 || viewMode === 2;
      this.limitCanvas(true, true);
      canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);
      canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);
      canvasData.left = (containerData.width - canvasData.width) / 2;
      canvasData.top = (containerData.height - canvasData.height) / 2;
      canvasData.oldLeft = canvasData.left;
      canvasData.oldTop = canvasData.top;
      this.initialCanvasData = assign({}, canvasData);
    },
    limitCanvas: function limitCanvas(sizeLimited, positionLimited) {
      var options = this.options,
          containerData = this.containerData,
          canvasData = this.canvasData,
          cropBoxData = this.cropBoxData;
      var viewMode = options.viewMode;
      var aspectRatio = canvasData.aspectRatio;
      var cropped = this.cropped && cropBoxData;

      if (sizeLimited) {
        var minCanvasWidth = Number(options.minCanvasWidth) || 0;
        var minCanvasHeight = Number(options.minCanvasHeight) || 0;

        if (viewMode > 1) {
          minCanvasWidth = Math.max(minCanvasWidth, containerData.width);
          minCanvasHeight = Math.max(minCanvasHeight, containerData.height);

          if (viewMode === 3) {
            if (minCanvasHeight * aspectRatio > minCanvasWidth) {
              minCanvasWidth = minCanvasHeight * aspectRatio;
            } else {
              minCanvasHeight = minCanvasWidth / aspectRatio;
            }
          }
        } else if (viewMode > 0) {
          if (minCanvasWidth) {
            minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBoxData.width : 0);
          } else if (minCanvasHeight) {
            minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBoxData.height : 0);
          } else if (cropped) {
            minCanvasWidth = cropBoxData.width;
            minCanvasHeight = cropBoxData.height;

            if (minCanvasHeight * aspectRatio > minCanvasWidth) {
              minCanvasWidth = minCanvasHeight * aspectRatio;
            } else {
              minCanvasHeight = minCanvasWidth / aspectRatio;
            }
          }
        }

        var _getAdjustedSizes = getAdjustedSizes({
          aspectRatio: aspectRatio,
          width: minCanvasWidth,
          height: minCanvasHeight
        });

        minCanvasWidth = _getAdjustedSizes.width;
        minCanvasHeight = _getAdjustedSizes.height;
        canvasData.minWidth = minCanvasWidth;
        canvasData.minHeight = minCanvasHeight;
        canvasData.maxWidth = Infinity;
        canvasData.maxHeight = Infinity;
      }

      if (positionLimited) {
        if (viewMode > (cropped ? 0 : 1)) {
          var newCanvasLeft = containerData.width - canvasData.width;
          var newCanvasTop = containerData.height - canvasData.height;
          canvasData.minLeft = Math.min(0, newCanvasLeft);
          canvasData.minTop = Math.min(0, newCanvasTop);
          canvasData.maxLeft = Math.max(0, newCanvasLeft);
          canvasData.maxTop = Math.max(0, newCanvasTop);

          if (cropped && this.limited) {
            canvasData.minLeft = Math.min(cropBoxData.left, cropBoxData.left + (cropBoxData.width - canvasData.width));
            canvasData.minTop = Math.min(cropBoxData.top, cropBoxData.top + (cropBoxData.height - canvasData.height));
            canvasData.maxLeft = cropBoxData.left;
            canvasData.maxTop = cropBoxData.top;

            if (viewMode === 2) {
              if (canvasData.width >= containerData.width) {
                canvasData.minLeft = Math.min(0, newCanvasLeft);
                canvasData.maxLeft = Math.max(0, newCanvasLeft);
              }

              if (canvasData.height >= containerData.height) {
                canvasData.minTop = Math.min(0, newCanvasTop);
                canvasData.maxTop = Math.max(0, newCanvasTop);
              }
            }
          }
        } else {
          canvasData.minLeft = -canvasData.width;
          canvasData.minTop = -canvasData.height;
          canvasData.maxLeft = containerData.width;
          canvasData.maxTop = containerData.height;
        }
      }
    },
    renderCanvas: function renderCanvas(changed, transformed) {
      var canvasData = this.canvasData,
          imageData = this.imageData;

      if (transformed) {
        var _getRotatedSizes = getRotatedSizes({
          width: imageData.naturalWidth * Math.abs(imageData.scaleX || 1),
          height: imageData.naturalHeight * Math.abs(imageData.scaleY || 1),
          degree: imageData.rotate || 0
        }),
            naturalWidth = _getRotatedSizes.width,
            naturalHeight = _getRotatedSizes.height;

        var width = canvasData.width * (naturalWidth / canvasData.naturalWidth);
        var height = canvasData.height * (naturalHeight / canvasData.naturalHeight);
        canvasData.left -= (width - canvasData.width) / 2;
        canvasData.top -= (height - canvasData.height) / 2;
        canvasData.width = width;
        canvasData.height = height;
        canvasData.aspectRatio = naturalWidth / naturalHeight;
        canvasData.naturalWidth = naturalWidth;
        canvasData.naturalHeight = naturalHeight;
        this.limitCanvas(true, false);
      }

      if (canvasData.width > canvasData.maxWidth || canvasData.width < canvasData.minWidth) {
        canvasData.left = canvasData.oldLeft;
      }

      if (canvasData.height > canvasData.maxHeight || canvasData.height < canvasData.minHeight) {
        canvasData.top = canvasData.oldTop;
      }

      canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);
      canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);
      this.limitCanvas(false, true);
      canvasData.left = Math.min(Math.max(canvasData.left, canvasData.minLeft), canvasData.maxLeft);
      canvasData.top = Math.min(Math.max(canvasData.top, canvasData.minTop), canvasData.maxTop);
      canvasData.oldLeft = canvasData.left;
      canvasData.oldTop = canvasData.top;
      setStyle(this.canvas, assign({
        width: canvasData.width,
        height: canvasData.height
      }, getTransforms({
        translateX: canvasData.left,
        translateY: canvasData.top
      })));
      this.renderImage(changed);

      if (this.cropped && this.limited) {
        this.limitCropBox(true, true);
      }
    },
    renderImage: function renderImage(changed) {
      var canvasData = this.canvasData,
          imageData = this.imageData;
      var width = imageData.naturalWidth * (canvasData.width / canvasData.naturalWidth);
      var height = imageData.naturalHeight * (canvasData.height / canvasData.naturalHeight);
      assign(imageData, {
        width: width,
        height: height,
        left: (canvasData.width - width) / 2,
        top: (canvasData.height - height) / 2
      });
      setStyle(this.image, assign({
        width: imageData.width,
        height: imageData.height
      }, getTransforms(assign({
        translateX: imageData.left,
        translateY: imageData.top
      }, imageData))));

      if (changed) {
        this.output();
      }
    },
    initCropBox: function initCropBox() {
      var options = this.options,
          canvasData = this.canvasData;
      var aspectRatio = options.aspectRatio || options.initialAspectRatio;
      var autoCropArea = Number(options.autoCropArea) || 0.8;
      var cropBoxData = {
        width: canvasData.width,
        height: canvasData.height
      };

      if (aspectRatio) {
        if (canvasData.height * aspectRatio > canvasData.width) {
          cropBoxData.height = cropBoxData.width / aspectRatio;
        } else {
          cropBoxData.width = cropBoxData.height * aspectRatio;
        }
      }

      this.cropBoxData = cropBoxData;
      this.limitCropBox(true, true); // Initialize auto crop area

      cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
      cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight); // The width/height of auto crop area must large than "minWidth/Height"

      cropBoxData.width = Math.max(cropBoxData.minWidth, cropBoxData.width * autoCropArea);
      cropBoxData.height = Math.max(cropBoxData.minHeight, cropBoxData.height * autoCropArea);
      cropBoxData.left = canvasData.left + (canvasData.width - cropBoxData.width) / 2;
      cropBoxData.top = canvasData.top + (canvasData.height - cropBoxData.height) / 2;
      cropBoxData.oldLeft = cropBoxData.left;
      cropBoxData.oldTop = cropBoxData.top;
      this.initialCropBoxData = assign({}, cropBoxData);
    },
    limitCropBox: function limitCropBox(sizeLimited, positionLimited) {
      var options = this.options,
          containerData = this.containerData,
          canvasData = this.canvasData,
          cropBoxData = this.cropBoxData,
          limited = this.limited;
      var aspectRatio = options.aspectRatio;

      if (sizeLimited) {
        var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;
        var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;
        var maxCropBoxWidth = limited ? Math.min(containerData.width, canvasData.width, canvasData.width + canvasData.left, containerData.width - canvasData.left) : containerData.width;
        var maxCropBoxHeight = limited ? Math.min(containerData.height, canvasData.height, canvasData.height + canvasData.top, containerData.height - canvasData.top) : containerData.height; // The min/maxCropBoxWidth/Height must be less than container's width/height

        minCropBoxWidth = Math.min(minCropBoxWidth, containerData.width);
        minCropBoxHeight = Math.min(minCropBoxHeight, containerData.height);

        if (aspectRatio) {
          if (minCropBoxWidth && minCropBoxHeight) {
            if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {
              minCropBoxHeight = minCropBoxWidth / aspectRatio;
            } else {
              minCropBoxWidth = minCropBoxHeight * aspectRatio;
            }
          } else if (minCropBoxWidth) {
            minCropBoxHeight = minCropBoxWidth / aspectRatio;
          } else if (minCropBoxHeight) {
            minCropBoxWidth = minCropBoxHeight * aspectRatio;
          }

          if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {
            maxCropBoxHeight = maxCropBoxWidth / aspectRatio;
          } else {
            maxCropBoxWidth = maxCropBoxHeight * aspectRatio;
          }
        } // The minWidth/Height must be less than maxWidth/Height


        cropBoxData.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);
        cropBoxData.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);
        cropBoxData.maxWidth = maxCropBoxWidth;
        cropBoxData.maxHeight = maxCropBoxHeight;
      }

      if (positionLimited) {
        if (limited) {
          cropBoxData.minLeft = Math.max(0, canvasData.left);
          cropBoxData.minTop = Math.max(0, canvasData.top);
          cropBoxData.maxLeft = Math.min(containerData.width, canvasData.left + canvasData.width) - cropBoxData.width;
          cropBoxData.maxTop = Math.min(containerData.height, canvasData.top + canvasData.height) - cropBoxData.height;
        } else {
          cropBoxData.minLeft = 0;
          cropBoxData.minTop = 0;
          cropBoxData.maxLeft = containerData.width - cropBoxData.width;
          cropBoxData.maxTop = containerData.height - cropBoxData.height;
        }
      }
    },
    renderCropBox: function renderCropBox() {
      var options = this.options,
          containerData = this.containerData,
          cropBoxData = this.cropBoxData;

      if (cropBoxData.width > cropBoxData.maxWidth || cropBoxData.width < cropBoxData.minWidth) {
        cropBoxData.left = cropBoxData.oldLeft;
      }

      if (cropBoxData.height > cropBoxData.maxHeight || cropBoxData.height < cropBoxData.minHeight) {
        cropBoxData.top = cropBoxData.oldTop;
      }

      cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
      cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);
      this.limitCropBox(false, true);
      cropBoxData.left = Math.min(Math.max(cropBoxData.left, cropBoxData.minLeft), cropBoxData.maxLeft);
      cropBoxData.top = Math.min(Math.max(cropBoxData.top, cropBoxData.minTop), cropBoxData.maxTop);
      cropBoxData.oldLeft = cropBoxData.left;
      cropBoxData.oldTop = cropBoxData.top;

      if (options.movable && options.cropBoxMovable) {
        // Turn to move the canvas when the crop box is equal to the container
        setData(this.face, DATA_ACTION, cropBoxData.width >= containerData.width && cropBoxData.height >= containerData.height ? ACTION_MOVE : ACTION_ALL);
      }

      setStyle(this.cropBox, assign({
        width: cropBoxData.width,
        height: cropBoxData.height
      }, getTransforms({
        translateX: cropBoxData.left,
        translateY: cropBoxData.top
      })));

      if (this.cropped && this.limited) {
        this.limitCanvas(true, true);
      }

      if (!this.disabled) {
        this.output();
      }
    },
    output: function output() {
      this.preview();
      dispatchEvent(this.element, EVENT_CROP, this.getData());
    }
  };

  var preview = {
    initPreview: function initPreview() {
      var element = this.element,
          crossOrigin = this.crossOrigin;
      var preview = this.options.preview;
      var url = crossOrigin ? this.crossOriginUrl : this.url;
      var alt = element.alt || 'The image to preview';
      var image = document.createElement('img');

      if (crossOrigin) {
        image.crossOrigin = crossOrigin;
      }

      image.src = url;
      image.alt = alt;
      this.viewBox.appendChild(image);
      this.viewBoxImage = image;

      if (!preview) {
        return;
      }

      var previews = preview;

      if (typeof preview === 'string') {
        previews = element.ownerDocument.querySelectorAll(preview);
      } else if (preview.querySelector) {
        previews = [preview];
      }

      this.previews = previews;
      forEach(previews, function (el) {
        var img = document.createElement('img'); // Save the original size for recover

        setData(el, DATA_PREVIEW, {
          width: el.offsetWidth,
          height: el.offsetHeight,
          html: el.innerHTML
        });

        if (crossOrigin) {
          img.crossOrigin = crossOrigin;
        }

        img.src = url;
        img.alt = alt;
        /**
         * Override img element styles
         * Add `display:block` to avoid margin top issue
         * Add `height:auto` to override `height` attribute on IE8
         * (Occur only when margin-top <= -height)
         */

        img.style.cssText = 'display:block;' + 'width:100%;' + 'height:auto;' + 'min-width:0!important;' + 'min-height:0!important;' + 'max-width:none!important;' + 'max-height:none!important;' + 'image-orientation:0deg!important;"';
        el.innerHTML = '';
        el.appendChild(img);
      });
    },
    resetPreview: function resetPreview() {
      forEach(this.previews, function (element) {
        var data = getData(element, DATA_PREVIEW);
        setStyle(element, {
          width: data.width,
          height: data.height
        });
        element.innerHTML = data.html;
        removeData(element, DATA_PREVIEW);
      });
    },
    preview: function preview() {
      var imageData = this.imageData,
          canvasData = this.canvasData,
          cropBoxData = this.cropBoxData;
      var cropBoxWidth = cropBoxData.width,
          cropBoxHeight = cropBoxData.height;
      var width = imageData.width,
          height = imageData.height;
      var left = cropBoxData.left - canvasData.left - imageData.left;
      var top = cropBoxData.top - canvasData.top - imageData.top;

      if (!this.cropped || this.disabled) {
        return;
      }

      setStyle(this.viewBoxImage, assign({
        width: width,
        height: height
      }, getTransforms(assign({
        translateX: -left,
        translateY: -top
      }, imageData))));
      forEach(this.previews, function (element) {
        var data = getData(element, DATA_PREVIEW);
        var originalWidth = data.width;
        var originalHeight = data.height;
        var newWidth = originalWidth;
        var newHeight = originalHeight;
        var ratio = 1;

        if (cropBoxWidth) {
          ratio = originalWidth / cropBoxWidth;
          newHeight = cropBoxHeight * ratio;
        }

        if (cropBoxHeight && newHeight > originalHeight) {
          ratio = originalHeight / cropBoxHeight;
          newWidth = cropBoxWidth * ratio;
          newHeight = originalHeight;
        }

        setStyle(element, {
          width: newWidth,
          height: newHeight
        });
        setStyle(element.getElementsByTagName('img')[0], assign({
          width: width * ratio,
          height: height * ratio
        }, getTransforms(assign({
          translateX: -left * ratio,
          translateY: -top * ratio
        }, imageData))));
      });
    }
  };

  var events = {
    bind: function bind() {
      var element = this.element,
          options = this.options,
          cropper = this.cropper;

      if (isFunction(options.cropstart)) {
        addListener(element, EVENT_CROP_START, options.cropstart);
      }

      if (isFunction(options.cropmove)) {
        addListener(element, EVENT_CROP_MOVE, options.cropmove);
      }

      if (isFunction(options.cropend)) {
        addListener(element, EVENT_CROP_END, options.cropend);
      }

      if (isFunction(options.crop)) {
        addListener(element, EVENT_CROP, options.crop);
      }

      if (isFunction(options.zoom)) {
        addListener(element, EVENT_ZOOM, options.zoom);
      }

      addListener(cropper, EVENT_POINTER_DOWN, this.onCropStart = this.cropStart.bind(this));

      if (options.zoomable && options.zoomOnWheel) {
        addListener(cropper, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {
          passive: false,
          capture: true
        });
      }

      if (options.toggleDragModeOnDblclick) {
        addListener(cropper, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));
      }

      addListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove = this.cropMove.bind(this));
      addListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd = this.cropEnd.bind(this));

      if (options.responsive) {
        addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));
      }
    },
    unbind: function unbind() {
      var element = this.element,
          options = this.options,
          cropper = this.cropper;

      if (isFunction(options.cropstart)) {
        removeListener(element, EVENT_CROP_START, options.cropstart);
      }

      if (isFunction(options.cropmove)) {
        removeListener(element, EVENT_CROP_MOVE, options.cropmove);
      }

      if (isFunction(options.cropend)) {
        removeListener(element, EVENT_CROP_END, options.cropend);
      }

      if (isFunction(options.crop)) {
        removeListener(element, EVENT_CROP, options.crop);
      }

      if (isFunction(options.zoom)) {
        removeListener(element, EVENT_ZOOM, options.zoom);
      }

      removeListener(cropper, EVENT_POINTER_DOWN, this.onCropStart);

      if (options.zoomable && options.zoomOnWheel) {
        removeListener(cropper, EVENT_WHEEL, this.onWheel, {
          passive: false,
          capture: true
        });
      }

      if (options.toggleDragModeOnDblclick) {
        removeListener(cropper, EVENT_DBLCLICK, this.onDblclick);
      }

      removeListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove);
      removeListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd);

      if (options.responsive) {
        removeListener(window, EVENT_RESIZE, this.onResize);
      }
    }
  };

  var handlers = {
    resize: function resize() {
      if (this.disabled) {
        return;
      }

      var options = this.options,
          container = this.container,
          containerData = this.containerData;
      var ratioX = container.offsetWidth / containerData.width;
      var ratioY = container.offsetHeight / containerData.height;
      var ratio = Math.abs(ratioX - 1) > Math.abs(ratioY - 1) ? ratioX : ratioY; // Resize when width changed or height changed

      if (ratio !== 1) {
        var canvasData;
        var cropBoxData;

        if (options.restore) {
          canvasData = this.getCanvasData();
          cropBoxData = this.getCropBoxData();
        }

        this.render();

        if (options.restore) {
          this.setCanvasData(forEach(canvasData, function (n, i) {
            canvasData[i] = n * ratio;
          }));
          this.setCropBoxData(forEach(cropBoxData, function (n, i) {
            cropBoxData[i] = n * ratio;
          }));
        }
      }
    },
    dblclick: function dblclick() {
      if (this.disabled || this.options.dragMode === DRAG_MODE_NONE) {
        return;
      }

      this.setDragMode(hasClass(this.dragBox, CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP);
    },
    wheel: function wheel(event) {
      var _this = this;

      var ratio = Number(this.options.wheelZoomRatio) || 0.1;
      var delta = 1;

      if (this.disabled) {
        return;
      }

      event.preventDefault(); // Limit wheel speed to prevent zoom too fast (#21)

      if (this.wheeling) {
        return;
      }

      this.wheeling = true;
      setTimeout(function () {
        _this.wheeling = false;
      }, 50);

      if (event.deltaY) {
        delta = event.deltaY > 0 ? 1 : -1;
      } else if (event.wheelDelta) {
        delta = -event.wheelDelta / 120;
      } else if (event.detail) {
        delta = event.detail > 0 ? 1 : -1;
      }

      this.zoom(-delta * ratio, event);
    },
    cropStart: function cropStart(event) {
      var buttons = event.buttons,
          button = event.button;

      if (this.disabled // Handle mouse event and pointer event and ignore touch event
      || (event.type === 'mousedown' || event.type === 'pointerdown' && event.pointerType === 'mouse') && ( // No primary button (Usually the left button)
      isNumber(buttons) && buttons !== 1 || isNumber(button) && button !== 0 // Open context menu
      || event.ctrlKey)) {
        return;
      }

      var options = this.options,
          pointers = this.pointers;
      var action;

      if (event.changedTouches) {
        // Handle touch event
        forEach(event.changedTouches, function (touch) {
          pointers[touch.identifier] = getPointer(touch);
        });
      } else {
        // Handle mouse event and pointer event
        pointers[event.pointerId || 0] = getPointer(event);
      }

      if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {
        action = ACTION_ZOOM;
      } else {
        action = getData(event.target, DATA_ACTION);
      }

      if (!REGEXP_ACTIONS.test(action)) {
        return;
      }

      if (dispatchEvent(this.element, EVENT_CROP_START, {
        originalEvent: event,
        action: action
      }) === false) {
        return;
      } // This line is required for preventing page zooming in iOS browsers


      event.preventDefault();
      this.action = action;
      this.cropping = false;

      if (action === ACTION_CROP) {
        this.cropping = true;
        addClass(this.dragBox, CLASS_MODAL);
      }
    },
    cropMove: function cropMove(event) {
      var action = this.action;

      if (this.disabled || !action) {
        return;
      }

      var pointers = this.pointers;
      event.preventDefault();

      if (dispatchEvent(this.element, EVENT_CROP_MOVE, {
        originalEvent: event,
        action: action
      }) === false) {
        return;
      }

      if (event.changedTouches) {
        forEach(event.changedTouches, function (touch) {
          // The first parameter should not be undefined (#432)
          assign(pointers[touch.identifier] || {}, getPointer(touch, true));
        });
      } else {
        assign(pointers[event.pointerId || 0] || {}, getPointer(event, true));
      }

      this.change(event);
    },
    cropEnd: function cropEnd(event) {
      if (this.disabled) {
        return;
      }

      var action = this.action,
          pointers = this.pointers;

      if (event.changedTouches) {
        forEach(event.changedTouches, function (touch) {
          delete pointers[touch.identifier];
        });
      } else {
        delete pointers[event.pointerId || 0];
      }

      if (!action) {
        return;
      }

      event.preventDefault();

      if (!Object.keys(pointers).length) {
        this.action = '';
      }

      if (this.cropping) {
        this.cropping = false;
        toggleClass(this.dragBox, CLASS_MODAL, this.cropped && this.options.modal);
      }

      dispatchEvent(this.element, EVENT_CROP_END, {
        originalEvent: event,
        action: action
      });
    }
  };

  var change = {
    change: function change(event) {
      var options = this.options,
          canvasData = this.canvasData,
          containerData = this.containerData,
          cropBoxData = this.cropBoxData,
          pointers = this.pointers;
      var action = this.action;
      var aspectRatio = options.aspectRatio;
      var left = cropBoxData.left,
          top = cropBoxData.top,
          width = cropBoxData.width,
          height = cropBoxData.height;
      var right = left + width;
      var bottom = top + height;
      var minLeft = 0;
      var minTop = 0;
      var maxWidth = containerData.width;
      var maxHeight = containerData.height;
      var renderable = true;
      var offset; // Locking aspect ratio in "free mode" by holding shift key

      if (!aspectRatio && event.shiftKey) {
        aspectRatio = width && height ? width / height : 1;
      }

      if (this.limited) {
        minLeft = cropBoxData.minLeft;
        minTop = cropBoxData.minTop;
        maxWidth = minLeft + Math.min(containerData.width, canvasData.width, canvasData.left + canvasData.width);
        maxHeight = minTop + Math.min(containerData.height, canvasData.height, canvasData.top + canvasData.height);
      }

      var pointer = pointers[Object.keys(pointers)[0]];
      var range = {
        x: pointer.endX - pointer.startX,
        y: pointer.endY - pointer.startY
      };

      var check = function check(side) {
        switch (side) {
          case ACTION_EAST:
            if (right + range.x > maxWidth) {
              range.x = maxWidth - right;
            }

            break;

          case ACTION_WEST:
            if (left + range.x < minLeft) {
              range.x = minLeft - left;
            }

            break;

          case ACTION_NORTH:
            if (top + range.y < minTop) {
              range.y = minTop - top;
            }

            break;

          case ACTION_SOUTH:
            if (bottom + range.y > maxHeight) {
              range.y = maxHeight - bottom;
            }

            break;
        }
      };

      switch (action) {
        // Move crop box
        case ACTION_ALL:
          left += range.x;
          top += range.y;
          break;
        // Resize crop box

        case ACTION_EAST:
          if (range.x >= 0 && (right >= maxWidth || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
            renderable = false;
            break;
          }

          check(ACTION_EAST);
          width += range.x;

          if (width < 0) {
            action = ACTION_WEST;
            width = -width;
            left -= width;
          }

          if (aspectRatio) {
            height = width / aspectRatio;
            top += (cropBoxData.height - height) / 2;
          }

          break;

        case ACTION_NORTH:
          if (range.y <= 0 && (top <= minTop || aspectRatio && (left <= minLeft || right >= maxWidth))) {
            renderable = false;
            break;
          }

          check(ACTION_NORTH);
          height -= range.y;
          top += range.y;

          if (height < 0) {
            action = ACTION_SOUTH;
            height = -height;
            top -= height;
          }

          if (aspectRatio) {
            width = height * aspectRatio;
            left += (cropBoxData.width - width) / 2;
          }

          break;

        case ACTION_WEST:
          if (range.x <= 0 && (left <= minLeft || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
            renderable = false;
            break;
          }

          check(ACTION_WEST);
          width -= range.x;
          left += range.x;

          if (width < 0) {
            action = ACTION_EAST;
            width = -width;
            left -= width;
          }

          if (aspectRatio) {
            height = width / aspectRatio;
            top += (cropBoxData.height - height) / 2;
          }

          break;

        case ACTION_SOUTH:
          if (range.y >= 0 && (bottom >= maxHeight || aspectRatio && (left <= minLeft || right >= maxWidth))) {
            renderable = false;
            break;
          }

          check(ACTION_SOUTH);
          height += range.y;

          if (height < 0) {
            action = ACTION_NORTH;
            height = -height;
            top -= height;
          }

          if (aspectRatio) {
            width = height * aspectRatio;
            left += (cropBoxData.width - width) / 2;
          }

          break;

        case ACTION_NORTH_EAST:
          if (aspectRatio) {
            if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {
              renderable = false;
              break;
            }

            check(ACTION_NORTH);
            height -= range.y;
            top += range.y;
            width = height * aspectRatio;
          } else {
            check(ACTION_NORTH);
            check(ACTION_EAST);

            if (range.x >= 0) {
              if (right < maxWidth) {
                width += range.x;
              } else if (range.y <= 0 && top <= minTop) {
                renderable = false;
              }
            } else {
              width += range.x;
            }

            if (range.y <= 0) {
              if (top > minTop) {
                height -= range.y;
                top += range.y;
              }
            } else {
              height -= range.y;
              top += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_SOUTH_WEST;
            height = -height;
            width = -width;
            top -= height;
            left -= width;
          } else if (width < 0) {
            action = ACTION_NORTH_WEST;
            width = -width;
            left -= width;
          } else if (height < 0) {
            action = ACTION_SOUTH_EAST;
            height = -height;
            top -= height;
          }

          break;

        case ACTION_NORTH_WEST:
          if (aspectRatio) {
            if (range.y <= 0 && (top <= minTop || left <= minLeft)) {
              renderable = false;
              break;
            }

            check(ACTION_NORTH);
            height -= range.y;
            top += range.y;
            width = height * aspectRatio;
            left += cropBoxData.width - width;
          } else {
            check(ACTION_NORTH);
            check(ACTION_WEST);

            if (range.x <= 0) {
              if (left > minLeft) {
                width -= range.x;
                left += range.x;
              } else if (range.y <= 0 && top <= minTop) {
                renderable = false;
              }
            } else {
              width -= range.x;
              left += range.x;
            }

            if (range.y <= 0) {
              if (top > minTop) {
                height -= range.y;
                top += range.y;
              }
            } else {
              height -= range.y;
              top += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_SOUTH_EAST;
            height = -height;
            width = -width;
            top -= height;
            left -= width;
          } else if (width < 0) {
            action = ACTION_NORTH_EAST;
            width = -width;
            left -= width;
          } else if (height < 0) {
            action = ACTION_SOUTH_WEST;
            height = -height;
            top -= height;
          }

          break;

        case ACTION_SOUTH_WEST:
          if (aspectRatio) {
            if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {
              renderable = false;
              break;
            }

            check(ACTION_WEST);
            width -= range.x;
            left += range.x;
            height = width / aspectRatio;
          } else {
            check(ACTION_SOUTH);
            check(ACTION_WEST);

            if (range.x <= 0) {
              if (left > minLeft) {
                width -= range.x;
                left += range.x;
              } else if (range.y >= 0 && bottom >= maxHeight) {
                renderable = false;
              }
            } else {
              width -= range.x;
              left += range.x;
            }

            if (range.y >= 0) {
              if (bottom < maxHeight) {
                height += range.y;
              }
            } else {
              height += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_NORTH_EAST;
            height = -height;
            width = -width;
            top -= height;
            left -= width;
          } else if (width < 0) {
            action = ACTION_SOUTH_EAST;
            width = -width;
            left -= width;
          } else if (height < 0) {
            action = ACTION_NORTH_WEST;
            height = -height;
            top -= height;
          }

          break;

        case ACTION_SOUTH_EAST:
          if (aspectRatio) {
            if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {
              renderable = false;
              break;
            }

            check(ACTION_EAST);
            width += range.x;
            height = width / aspectRatio;
          } else {
            check(ACTION_SOUTH);
            check(ACTION_EAST);

            if (range.x >= 0) {
              if (right < maxWidth) {
                width += range.x;
              } else if (range.y >= 0 && bottom >= maxHeight) {
                renderable = false;
              }
            } else {
              width += range.x;
            }

            if (range.y >= 0) {
              if (bottom < maxHeight) {
                height += range.y;
              }
            } else {
              height += range.y;
            }
          }

          if (width < 0 && height < 0) {
            action = ACTION_NORTH_WEST;
            height = -height;
            width = -width;
            top -= height;
            left -= width;
          } else if (width < 0) {
            action = ACTION_SOUTH_WEST;
            width = -width;
            left -= width;
          } else if (height < 0) {
            action = ACTION_NORTH_EAST;
            height = -height;
            top -= height;
          }

          break;
        // Move canvas

        case ACTION_MOVE:
          this.move(range.x, range.y);
          renderable = false;
          break;
        // Zoom canvas

        case ACTION_ZOOM:
          this.zoom(getMaxZoomRatio(pointers), event);
          renderable = false;
          break;
        // Create crop box

        case ACTION_CROP:
          if (!range.x || !range.y) {
            renderable = false;
            break;
          }

          offset = getOffset(this.cropper);
          left = pointer.startX - offset.left;
          top = pointer.startY - offset.top;
          width = cropBoxData.minWidth;
          height = cropBoxData.minHeight;

          if (range.x > 0) {
            action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;
          } else if (range.x < 0) {
            left -= width;
            action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;
          }

          if (range.y < 0) {
            top -= height;
          } // Show the crop box if is hidden


          if (!this.cropped) {
            removeClass(this.cropBox, CLASS_HIDDEN);
            this.cropped = true;

            if (this.limited) {
              this.limitCropBox(true, true);
            }
          }

          break;
      }

      if (renderable) {
        cropBoxData.width = width;
        cropBoxData.height = height;
        cropBoxData.left = left;
        cropBoxData.top = top;
        this.action = action;
        this.renderCropBox();
      } // Override


      forEach(pointers, function (p) {
        p.startX = p.endX;
        p.startY = p.endY;
      });
    }
  };

  var methods = {
    // Show the crop box manually
    crop: function crop() {
      if (this.ready && !this.cropped && !this.disabled) {
        this.cropped = true;
        this.limitCropBox(true, true);

        if (this.options.modal) {
          addClass(this.dragBox, CLASS_MODAL);
        }

        removeClass(this.cropBox, CLASS_HIDDEN);
        this.setCropBoxData(this.initialCropBoxData);
      }

      return this;
    },
    // Reset the image and crop box to their initial states
    reset: function reset() {
      if (this.ready && !this.disabled) {
        this.imageData = assign({}, this.initialImageData);
        this.canvasData = assign({}, this.initialCanvasData);
        this.cropBoxData = assign({}, this.initialCropBoxData);
        this.renderCanvas();

        if (this.cropped) {
          this.renderCropBox();
        }
      }

      return this;
    },
    // Clear the crop box
    clear: function clear() {
      if (this.cropped && !this.disabled) {
        assign(this.cropBoxData, {
          left: 0,
          top: 0,
          width: 0,
          height: 0
        });
        this.cropped = false;
        this.renderCropBox();
        this.limitCanvas(true, true); // Render canvas after crop box rendered

        this.renderCanvas();
        removeClass(this.dragBox, CLASS_MODAL);
        addClass(this.cropBox, CLASS_HIDDEN);
      }

      return this;
    },

    /**
     * Replace the image's src and rebuild the cropper
     * @param {string} url - The new URL.
     * @param {boolean} [hasSameSize] - Indicate if the new image has the same size as the old one.
     * @returns {Cropper} this
     */
    replace: function replace(url) {
      var hasSameSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!this.disabled && url) {
        if (this.isImg) {
          this.element.src = url;
        }

        if (hasSameSize) {
          this.url = url;
          this.image.src = url;

          if (this.ready) {
            this.viewBoxImage.src = url;
            forEach(this.previews, function (element) {
              element.getElementsByTagName('img')[0].src = url;
            });
          }
        } else {
          if (this.isImg) {
            this.replaced = true;
          }

          this.options.data = null;
          this.uncreate();
          this.load(url);
        }
      }

      return this;
    },
    // Enable (unfreeze) the cropper
    enable: function enable() {
      if (this.ready && this.disabled) {
        this.disabled = false;
        removeClass(this.cropper, CLASS_DISABLED);
      }

      return this;
    },
    // Disable (freeze) the cropper
    disable: function disable() {
      if (this.ready && !this.disabled) {
        this.disabled = true;
        addClass(this.cropper, CLASS_DISABLED);
      }

      return this;
    },

    /**
     * Destroy the cropper and remove the instance from the image
     * @returns {Cropper} this
     */
    destroy: function destroy() {
      var element = this.element;

      if (!element[NAMESPACE]) {
        return this;
      }

      element[NAMESPACE] = undefined;

      if (this.isImg && this.replaced) {
        element.src = this.originalUrl;
      }

      this.uncreate();
      return this;
    },

    /**
     * Move the canvas with relative offsets
     * @param {number} offsetX - The relative offset distance on the x-axis.
     * @param {number} [offsetY=offsetX] - The relative offset distance on the y-axis.
     * @returns {Cropper} this
     */
    move: function move(offsetX) {
      var offsetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : offsetX;
      var _this$canvasData = this.canvasData,
          left = _this$canvasData.left,
          top = _this$canvasData.top;
      return this.moveTo(isUndefined(offsetX) ? offsetX : left + Number(offsetX), isUndefined(offsetY) ? offsetY : top + Number(offsetY));
    },

    /**
     * Move the canvas to an absolute point
     * @param {number} x - The x-axis coordinate.
     * @param {number} [y=x] - The y-axis coordinate.
     * @returns {Cropper} this
     */
    moveTo: function moveTo(x) {
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
      var canvasData = this.canvasData;
      var changed = false;
      x = Number(x);
      y = Number(y);

      if (this.ready && !this.disabled && this.options.movable) {
        if (isNumber(x)) {
          canvasData.left = x;
          changed = true;
        }

        if (isNumber(y)) {
          canvasData.top = y;
          changed = true;
        }

        if (changed) {
          this.renderCanvas(true);
        }
      }

      return this;
    },

    /**
     * Zoom the canvas with a relative ratio
     * @param {number} ratio - The target ratio.
     * @param {Event} _originalEvent - The original event if any.
     * @returns {Cropper} this
     */
    zoom: function zoom(ratio, _originalEvent) {
      var canvasData = this.canvasData;
      ratio = Number(ratio);

      if (ratio < 0) {
        ratio = 1 / (1 - ratio);
      } else {
        ratio = 1 + ratio;
      }

      return this.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, null, _originalEvent);
    },

    /**
     * Zoom the canvas to an absolute ratio
     * @param {number} ratio - The target ratio.
     * @param {Object} pivot - The zoom pivot point coordinate.
     * @param {Event} _originalEvent - The original event if any.
     * @returns {Cropper} this
     */
    zoomTo: function zoomTo(ratio, pivot, _originalEvent) {
      var options = this.options,
          canvasData = this.canvasData;
      var width = canvasData.width,
          height = canvasData.height,
          naturalWidth = canvasData.naturalWidth,
          naturalHeight = canvasData.naturalHeight;
      ratio = Number(ratio);

      if (ratio >= 0 && this.ready && !this.disabled && options.zoomable) {
        var newWidth = naturalWidth * ratio;
        var newHeight = naturalHeight * ratio;

        if (dispatchEvent(this.element, EVENT_ZOOM, {
          ratio: ratio,
          oldRatio: width / naturalWidth,
          originalEvent: _originalEvent
        }) === false) {
          return this;
        }

        if (_originalEvent) {
          var pointers = this.pointers;
          var offset = getOffset(this.cropper);
          var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {
            pageX: _originalEvent.pageX,
            pageY: _originalEvent.pageY
          }; // Zoom from the triggering point of the event

          canvasData.left -= (newWidth - width) * ((center.pageX - offset.left - canvasData.left) / width);
          canvasData.top -= (newHeight - height) * ((center.pageY - offset.top - canvasData.top) / height);
        } else if (isPlainObject(pivot) && isNumber(pivot.x) && isNumber(pivot.y)) {
          canvasData.left -= (newWidth - width) * ((pivot.x - canvasData.left) / width);
          canvasData.top -= (newHeight - height) * ((pivot.y - canvasData.top) / height);
        } else {
          // Zoom from the center of the canvas
          canvasData.left -= (newWidth - width) / 2;
          canvasData.top -= (newHeight - height) / 2;
        }

        canvasData.width = newWidth;
        canvasData.height = newHeight;
        this.renderCanvas(true);
      }

      return this;
    },

    /**
     * Rotate the canvas with a relative degree
     * @param {number} degree - The rotate degree.
     * @returns {Cropper} this
     */
    rotate: function rotate(degree) {
      return this.rotateTo((this.imageData.rotate || 0) + Number(degree));
    },

    /**
     * Rotate the canvas to an absolute degree
     * @param {number} degree - The rotate degree.
     * @returns {Cropper} this
     */
    rotateTo: function rotateTo(degree) {
      degree = Number(degree);

      if (isNumber(degree) && this.ready && !this.disabled && this.options.rotatable) {
        this.imageData.rotate = degree % 360;
        this.renderCanvas(true, true);
      }

      return this;
    },

    /**
     * Scale the image on the x-axis.
     * @param {number} scaleX - The scale ratio on the x-axis.
     * @returns {Cropper} this
     */
    scaleX: function scaleX(_scaleX) {
      var scaleY = this.imageData.scaleY;
      return this.scale(_scaleX, isNumber(scaleY) ? scaleY : 1);
    },

    /**
     * Scale the image on the y-axis.
     * @param {number} scaleY - The scale ratio on the y-axis.
     * @returns {Cropper} this
     */
    scaleY: function scaleY(_scaleY) {
      var scaleX = this.imageData.scaleX;
      return this.scale(isNumber(scaleX) ? scaleX : 1, _scaleY);
    },

    /**
     * Scale the image
     * @param {number} scaleX - The scale ratio on the x-axis.
     * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.
     * @returns {Cropper} this
     */
    scale: function scale(scaleX) {
      var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;
      var imageData = this.imageData;
      var transformed = false;
      scaleX = Number(scaleX);
      scaleY = Number(scaleY);

      if (this.ready && !this.disabled && this.options.scalable) {
        if (isNumber(scaleX)) {
          imageData.scaleX = scaleX;
          transformed = true;
        }

        if (isNumber(scaleY)) {
          imageData.scaleY = scaleY;
          transformed = true;
        }

        if (transformed) {
          this.renderCanvas(true, true);
        }
      }

      return this;
    },

    /**
     * Get the cropped area position and size data (base on the original image)
     * @param {boolean} [rounded=false] - Indicate if round the data values or not.
     * @returns {Object} The result cropped data.
     */
    getData: function getData() {
      var rounded = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var options = this.options,
          imageData = this.imageData,
          canvasData = this.canvasData,
          cropBoxData = this.cropBoxData;
      var data;

      if (this.ready && this.cropped) {
        data = {
          x: cropBoxData.left - canvasData.left,
          y: cropBoxData.top - canvasData.top,
          width: cropBoxData.width,
          height: cropBoxData.height
        };
        var ratio = imageData.width / imageData.naturalWidth;
        forEach(data, function (n, i) {
          data[i] = n / ratio;
        });

        if (rounded) {
          // In case rounding off leads to extra 1px in right or bottom border
          // we should round the top-left corner and the dimension (#343).
          var bottom = Math.round(data.y + data.height);
          var right = Math.round(data.x + data.width);
          data.x = Math.round(data.x);
          data.y = Math.round(data.y);
          data.width = right - data.x;
          data.height = bottom - data.y;
        }
      } else {
        data = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }

      if (options.rotatable) {
        data.rotate = imageData.rotate || 0;
      }

      if (options.scalable) {
        data.scaleX = imageData.scaleX || 1;
        data.scaleY = imageData.scaleY || 1;
      }

      return data;
    },

    /**
     * Set the cropped area position and size with new data
     * @param {Object} data - The new data.
     * @returns {Cropper} this
     */
    setData: function setData(data) {
      var options = this.options,
          imageData = this.imageData,
          canvasData = this.canvasData;
      var cropBoxData = {};

      if (this.ready && !this.disabled && isPlainObject(data)) {
        var transformed = false;

        if (options.rotatable) {
          if (isNumber(data.rotate) && data.rotate !== imageData.rotate) {
            imageData.rotate = data.rotate;
            transformed = true;
          }
        }

        if (options.scalable) {
          if (isNumber(data.scaleX) && data.scaleX !== imageData.scaleX) {
            imageData.scaleX = data.scaleX;
            transformed = true;
          }

          if (isNumber(data.scaleY) && data.scaleY !== imageData.scaleY) {
            imageData.scaleY = data.scaleY;
            transformed = true;
          }
        }

        if (transformed) {
          this.renderCanvas(true, true);
        }

        var ratio = imageData.width / imageData.naturalWidth;

        if (isNumber(data.x)) {
          cropBoxData.left = data.x * ratio + canvasData.left;
        }

        if (isNumber(data.y)) {
          cropBoxData.top = data.y * ratio + canvasData.top;
        }

        if (isNumber(data.width)) {
          cropBoxData.width = data.width * ratio;
        }

        if (isNumber(data.height)) {
          cropBoxData.height = data.height * ratio;
        }

        this.setCropBoxData(cropBoxData);
      }

      return this;
    },

    /**
     * Get the container size data.
     * @returns {Object} The result container data.
     */
    getContainerData: function getContainerData() {
      return this.ready ? assign({}, this.containerData) : {};
    },

    /**
     * Get the image position and size data.
     * @returns {Object} The result image data.
     */
    getImageData: function getImageData() {
      return this.sized ? assign({}, this.imageData) : {};
    },

    /**
     * Get the canvas position and size data.
     * @returns {Object} The result canvas data.
     */
    getCanvasData: function getCanvasData() {
      var canvasData = this.canvasData;
      var data = {};

      if (this.ready) {
        forEach(['left', 'top', 'width', 'height', 'naturalWidth', 'naturalHeight'], function (n) {
          data[n] = canvasData[n];
        });
      }

      return data;
    },

    /**
     * Set the canvas position and size with new data.
     * @param {Object} data - The new canvas data.
     * @returns {Cropper} this
     */
    setCanvasData: function setCanvasData(data) {
      var canvasData = this.canvasData;
      var aspectRatio = canvasData.aspectRatio;

      if (this.ready && !this.disabled && isPlainObject(data)) {
        if (isNumber(data.left)) {
          canvasData.left = data.left;
        }

        if (isNumber(data.top)) {
          canvasData.top = data.top;
        }

        if (isNumber(data.width)) {
          canvasData.width = data.width;
          canvasData.height = data.width / aspectRatio;
        } else if (isNumber(data.height)) {
          canvasData.height = data.height;
          canvasData.width = data.height * aspectRatio;
        }

        this.renderCanvas(true);
      }

      return this;
    },

    /**
     * Get the crop box position and size data.
     * @returns {Object} The result crop box data.
     */
    getCropBoxData: function getCropBoxData() {
      var cropBoxData = this.cropBoxData;
      var data;

      if (this.ready && this.cropped) {
        data = {
          left: cropBoxData.left,
          top: cropBoxData.top,
          width: cropBoxData.width,
          height: cropBoxData.height
        };
      }

      return data || {};
    },

    /**
     * Set the crop box position and size with new data.
     * @param {Object} data - The new crop box data.
     * @returns {Cropper} this
     */
    setCropBoxData: function setCropBoxData(data) {
      var cropBoxData = this.cropBoxData;
      var aspectRatio = this.options.aspectRatio;
      var widthChanged;
      var heightChanged;

      if (this.ready && this.cropped && !this.disabled && isPlainObject(data)) {
        if (isNumber(data.left)) {
          cropBoxData.left = data.left;
        }

        if (isNumber(data.top)) {
          cropBoxData.top = data.top;
        }

        if (isNumber(data.width) && data.width !== cropBoxData.width) {
          widthChanged = true;
          cropBoxData.width = data.width;
        }

        if (isNumber(data.height) && data.height !== cropBoxData.height) {
          heightChanged = true;
          cropBoxData.height = data.height;
        }

        if (aspectRatio) {
          if (widthChanged) {
            cropBoxData.height = cropBoxData.width / aspectRatio;
          } else if (heightChanged) {
            cropBoxData.width = cropBoxData.height * aspectRatio;
          }
        }

        this.renderCropBox();
      }

      return this;
    },

    /**
     * Get a canvas drawn the cropped image.
     * @param {Object} [options={}] - The config options.
     * @returns {HTMLCanvasElement} - The result canvas.
     */
    getCroppedCanvas: function getCroppedCanvas() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!this.ready || !window.HTMLCanvasElement) {
        return null;
      }

      var canvasData = this.canvasData;
      var source = getSourceCanvas(this.image, this.imageData, canvasData, options); // Returns the source canvas if it is not cropped.

      if (!this.cropped) {
        return source;
      }

      var _this$getData = this.getData(),
          initialX = _this$getData.x,
          initialY = _this$getData.y,
          initialWidth = _this$getData.width,
          initialHeight = _this$getData.height;

      var ratio = source.width / Math.floor(canvasData.naturalWidth);

      if (ratio !== 1) {
        initialX *= ratio;
        initialY *= ratio;
        initialWidth *= ratio;
        initialHeight *= ratio;
      }

      var aspectRatio = initialWidth / initialHeight;
      var maxSizes = getAdjustedSizes({
        aspectRatio: aspectRatio,
        width: options.maxWidth || Infinity,
        height: options.maxHeight || Infinity
      });
      var minSizes = getAdjustedSizes({
        aspectRatio: aspectRatio,
        width: options.minWidth || 0,
        height: options.minHeight || 0
      }, 'cover');

      var _getAdjustedSizes = getAdjustedSizes({
        aspectRatio: aspectRatio,
        width: options.width || (ratio !== 1 ? source.width : initialWidth),
        height: options.height || (ratio !== 1 ? source.height : initialHeight)
      }),
          width = _getAdjustedSizes.width,
          height = _getAdjustedSizes.height;

      width = Math.min(maxSizes.width, Math.max(minSizes.width, width));
      height = Math.min(maxSizes.height, Math.max(minSizes.height, height));
      var canvas = document.createElement('canvas');
      var context = canvas.getContext('2d');
      canvas.width = normalizeDecimalNumber(width);
      canvas.height = normalizeDecimalNumber(height);
      context.fillStyle = options.fillColor || 'transparent';
      context.fillRect(0, 0, width, height);
      var _options$imageSmoothi = options.imageSmoothingEnabled,
          imageSmoothingEnabled = _options$imageSmoothi === void 0 ? true : _options$imageSmoothi,
          imageSmoothingQuality = options.imageSmoothingQuality;
      context.imageSmoothingEnabled = imageSmoothingEnabled;

      if (imageSmoothingQuality) {
        context.imageSmoothingQuality = imageSmoothingQuality;
      } // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D.drawImage


      var sourceWidth = source.width;
      var sourceHeight = source.height; // Source canvas parameters

      var srcX = initialX;
      var srcY = initialY;
      var srcWidth;
      var srcHeight; // Destination canvas parameters

      var dstX;
      var dstY;
      var dstWidth;
      var dstHeight;

      if (srcX <= -initialWidth || srcX > sourceWidth) {
        srcX = 0;
        srcWidth = 0;
        dstX = 0;
        dstWidth = 0;
      } else if (srcX <= 0) {
        dstX = -srcX;
        srcX = 0;
        srcWidth = Math.min(sourceWidth, initialWidth + srcX);
        dstWidth = srcWidth;
      } else if (srcX <= sourceWidth) {
        dstX = 0;
        srcWidth = Math.min(initialWidth, sourceWidth - srcX);
        dstWidth = srcWidth;
      }

      if (srcWidth <= 0 || srcY <= -initialHeight || srcY > sourceHeight) {
        srcY = 0;
        srcHeight = 0;
        dstY = 0;
        dstHeight = 0;
      } else if (srcY <= 0) {
        dstY = -srcY;
        srcY = 0;
        srcHeight = Math.min(sourceHeight, initialHeight + srcY);
        dstHeight = srcHeight;
      } else if (srcY <= sourceHeight) {
        dstY = 0;
        srcHeight = Math.min(initialHeight, sourceHeight - srcY);
        dstHeight = srcHeight;
      }

      var params = [srcX, srcY, srcWidth, srcHeight]; // Avoid "IndexSizeError"

      if (dstWidth > 0 && dstHeight > 0) {
        var scale = width / initialWidth;
        params.push(dstX * scale, dstY * scale, dstWidth * scale, dstHeight * scale);
      } // All the numerical parameters should be integer for `drawImage`
      // https://github.com/fengyuanchen/cropper/issues/476


      context.drawImage.apply(context, [source].concat(_toConsumableArray(params.map(function (param) {
        return Math.floor(normalizeDecimalNumber(param));
      }))));
      return canvas;
    },

    /**
     * Change the aspect ratio of the crop box.
     * @param {number} aspectRatio - The new aspect ratio.
     * @returns {Cropper} this
     */
    setAspectRatio: function setAspectRatio(aspectRatio) {
      var options = this.options;

      if (!this.disabled && !isUndefined(aspectRatio)) {
        // 0 -> NaN
        options.aspectRatio = Math.max(0, aspectRatio) || NaN;

        if (this.ready) {
          this.initCropBox();

          if (this.cropped) {
            this.renderCropBox();
          }
        }
      }

      return this;
    },

    /**
     * Change the drag mode.
     * @param {string} mode - The new drag mode.
     * @returns {Cropper} this
     */
    setDragMode: function setDragMode(mode) {
      var options = this.options,
          dragBox = this.dragBox,
          face = this.face;

      if (this.ready && !this.disabled) {
        var croppable = mode === DRAG_MODE_CROP;
        var movable = options.movable && mode === DRAG_MODE_MOVE;
        mode = croppable || movable ? mode : DRAG_MODE_NONE;
        options.dragMode = mode;
        setData(dragBox, DATA_ACTION, mode);
        toggleClass(dragBox, CLASS_CROP, croppable);
        toggleClass(dragBox, CLASS_MOVE, movable);

        if (!options.cropBoxMovable) {
          // Sync drag mode to crop box when it is not movable
          setData(face, DATA_ACTION, mode);
          toggleClass(face, CLASS_CROP, croppable);
          toggleClass(face, CLASS_MOVE, movable);
        }
      }

      return this;
    }
  };

  var AnotherCropper = WINDOW.Cropper;

  var Cropper = /*#__PURE__*/function () {
    /**
     * Create a new Cropper.
     * @param {Element} element - The target element for cropping.
     * @param {Object} [options={}] - The configuration options.
     */
    function Cropper(element) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Cropper);

      if (!element || !REGEXP_TAG_NAME.test(element.tagName)) {
        throw new Error('The first argument is required and must be an <img> or <canvas> element.');
      }

      this.element = element;
      this.options = assign({}, DEFAULTS, isPlainObject(options) && options);
      this.cropped = false;
      this.disabled = false;
      this.pointers = {};
      this.ready = false;
      this.reloading = false;
      this.replaced = false;
      this.sized = false;
      this.sizing = false;
      this.init();
    }

    _createClass(Cropper, [{
      key: "init",
      value: function init() {
        var element = this.element;
        var tagName = element.tagName.toLowerCase();
        var url;

        if (element[NAMESPACE]) {
          return;
        }

        element[NAMESPACE] = this;

        if (tagName === 'img') {
          this.isImg = true; // e.g.: "img/picture.jpg"

          url = element.getAttribute('src') || '';
          this.originalUrl = url; // Stop when it's a blank image

          if (!url) {
            return;
          } // e.g.: "img/picture.jpg"


          url = element.src;
        } else if (tagName === 'canvas' && window.HTMLCanvasElement) {
          url = element.toDataURL();
        }

        this.load(url);
      }
    }, {
      key: "load",
      value: function load(url) {
        var _this = this;

        if (!url) {
          return;
        }

        this.url = url;
        this.imageData = {};
        var element = this.element,
            options = this.options;

        if (!options.rotatable && !options.scalable) {
          options.checkOrientation = false;
        } // Only IE10+ supports Typed Arrays


        if (!options.checkOrientation || !window.ArrayBuffer) {
          this.clone();
          return;
        } // Detect the mime type of the image directly if it is a Data URL


        if (REGEXP_DATA_URL.test(url)) {
          // Read ArrayBuffer from Data URL of JPEG images directly for better performance
          if (REGEXP_DATA_URL_JPEG.test(url)) {
            this.read(dataURLToArrayBuffer(url));
          } else {
            // Only a JPEG image may contains Exif Orientation information,
            // the rest types of Data URLs are not necessary to check orientation at all.
            this.clone();
          }

          return;
        } // 1. Detect the mime type of the image by a XMLHttpRequest.
        // 2. Load the image as ArrayBuffer for reading orientation if its a JPEG image.


        var xhr = new XMLHttpRequest();
        var clone = this.clone.bind(this);
        this.reloading = true;
        this.xhr = xhr; // 1. Cross origin requests are only supported for protocol schemes:
        // http, https, data, chrome, chrome-extension.
        // 2. Access to XMLHttpRequest from a Data URL will be blocked by CORS policy
        // in some browsers as IE11 and Safari.

        xhr.onabort = clone;
        xhr.onerror = clone;
        xhr.ontimeout = clone;

        xhr.onprogress = function () {
          // Abort the request directly if it not a JPEG image for better performance
          if (xhr.getResponseHeader('content-type') !== MIME_TYPE_JPEG) {
            xhr.abort();
          }
        };

        xhr.onload = function () {
          _this.read(xhr.response);
        };

        xhr.onloadend = function () {
          _this.reloading = false;
          _this.xhr = null;
        }; // Bust cache when there is a "crossOrigin" property to avoid browser cache error


        if (options.checkCrossOrigin && isCrossOriginURL(url) && element.crossOrigin) {
          url = addTimestamp(url);
        } // The third parameter is required for avoiding side-effect (#682)


        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.withCredentials = element.crossOrigin === 'use-credentials';
        xhr.send();
      }
    }, {
      key: "read",
      value: function read(arrayBuffer) {
        var options = this.options,
            imageData = this.imageData; // Reset the orientation value to its default value 1
        // as some iOS browsers will render image with its orientation

        var orientation = resetAndGetOrientation(arrayBuffer);
        var rotate = 0;
        var scaleX = 1;
        var scaleY = 1;

        if (orientation > 1) {
          // Generate a new URL which has the default orientation value
          this.url = arrayBufferToDataURL(arrayBuffer, MIME_TYPE_JPEG);

          var _parseOrientation = parseOrientation(orientation);

          rotate = _parseOrientation.rotate;
          scaleX = _parseOrientation.scaleX;
          scaleY = _parseOrientation.scaleY;
        }

        if (options.rotatable) {
          imageData.rotate = rotate;
        }

        if (options.scalable) {
          imageData.scaleX = scaleX;
          imageData.scaleY = scaleY;
        }

        this.clone();
      }
    }, {
      key: "clone",
      value: function clone() {
        var element = this.element,
            url = this.url;
        var crossOrigin = element.crossOrigin;
        var crossOriginUrl = url;

        if (this.options.checkCrossOrigin && isCrossOriginURL(url)) {
          if (!crossOrigin) {
            crossOrigin = 'anonymous';
          } // Bust cache when there is not a "crossOrigin" property (#519)


          crossOriginUrl = addTimestamp(url);
        }

        this.crossOrigin = crossOrigin;
        this.crossOriginUrl = crossOriginUrl;
        var image = document.createElement('img');

        if (crossOrigin) {
          image.crossOrigin = crossOrigin;
        }

        image.src = crossOriginUrl || url;
        image.alt = element.alt || 'The image to crop';
        this.image = image;
        image.onload = this.start.bind(this);
        image.onerror = this.stop.bind(this);
        addClass(image, CLASS_HIDE);
        element.parentNode.insertBefore(image, element.nextSibling);
      }
    }, {
      key: "start",
      value: function start() {
        var _this2 = this;

        var image = this.image;
        image.onload = null;
        image.onerror = null;
        this.sizing = true; // Match all browsers that use WebKit as the layout engine in iOS devices,
        // such as Safari for iOS, Chrome for iOS, and in-app browsers.

        var isIOSWebKit = WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent);

        var done = function done(naturalWidth, naturalHeight) {
          assign(_this2.imageData, {
            naturalWidth: naturalWidth,
            naturalHeight: naturalHeight,
            aspectRatio: naturalWidth / naturalHeight
          });
          _this2.initialImageData = assign({}, _this2.imageData);
          _this2.sizing = false;
          _this2.sized = true;

          _this2.build();
        }; // Most modern browsers (excepts iOS WebKit)


        if (image.naturalWidth && !isIOSWebKit) {
          done(image.naturalWidth, image.naturalHeight);
          return;
        }

        var sizingImage = document.createElement('img');
        var body = document.body || document.documentElement;
        this.sizingImage = sizingImage;

        sizingImage.onload = function () {
          done(sizingImage.width, sizingImage.height);

          if (!isIOSWebKit) {
            body.removeChild(sizingImage);
          }
        };

        sizingImage.src = image.src; // iOS WebKit will convert the image automatically
        // with its orientation once append it into DOM (#279)

        if (!isIOSWebKit) {
          sizingImage.style.cssText = 'left:0;' + 'max-height:none!important;' + 'max-width:none!important;' + 'min-height:0!important;' + 'min-width:0!important;' + 'opacity:0;' + 'position:absolute;' + 'top:0;' + 'z-index:-1;';
          body.appendChild(sizingImage);
        }
      }
    }, {
      key: "stop",
      value: function stop() {
        var image = this.image;
        image.onload = null;
        image.onerror = null;
        image.parentNode.removeChild(image);
        this.image = null;
      }
    }, {
      key: "build",
      value: function build() {
        if (!this.sized || this.ready) {
          return;
        }

        var element = this.element,
            options = this.options,
            image = this.image; // Create cropper elements

        var container = element.parentNode;
        var template = document.createElement('div');
        template.innerHTML = TEMPLATE;
        var cropper = template.querySelector(".".concat(NAMESPACE, "-container"));
        var canvas = cropper.querySelector(".".concat(NAMESPACE, "-canvas"));
        var dragBox = cropper.querySelector(".".concat(NAMESPACE, "-drag-box"));
        var cropBox = cropper.querySelector(".".concat(NAMESPACE, "-crop-box"));
        var face = cropBox.querySelector(".".concat(NAMESPACE, "-face"));
        this.container = container;
        this.cropper = cropper;
        this.canvas = canvas;
        this.dragBox = dragBox;
        this.cropBox = cropBox;
        this.viewBox = cropper.querySelector(".".concat(NAMESPACE, "-view-box"));
        this.face = face;
        canvas.appendChild(image); // Hide the original image

        addClass(element, CLASS_HIDDEN); // Inserts the cropper after to the current image

        container.insertBefore(cropper, element.nextSibling); // Show the image if is hidden

        if (!this.isImg) {
          removeClass(image, CLASS_HIDE);
        }

        this.initPreview();
        this.bind();
        options.initialAspectRatio = Math.max(0, options.initialAspectRatio) || NaN;
        options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;
        options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;
        addClass(cropBox, CLASS_HIDDEN);

        if (!options.guides) {
          addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-dashed")), CLASS_HIDDEN);
        }

        if (!options.center) {
          addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-center")), CLASS_HIDDEN);
        }

        if (options.background) {
          addClass(cropper, "".concat(NAMESPACE, "-bg"));
        }

        if (!options.highlight) {
          addClass(face, CLASS_INVISIBLE);
        }

        if (options.cropBoxMovable) {
          addClass(face, CLASS_MOVE);
          setData(face, DATA_ACTION, ACTION_ALL);
        }

        if (!options.cropBoxResizable) {
          addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-line")), CLASS_HIDDEN);
          addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-point")), CLASS_HIDDEN);
        }

        this.render();
        this.ready = true;
        this.setDragMode(options.dragMode);

        if (options.autoCrop) {
          this.crop();
        }

        this.setData(options.data);

        if (isFunction(options.ready)) {
          addListener(element, EVENT_READY, options.ready, {
            once: true
          });
        }

        dispatchEvent(element, EVENT_READY);
      }
    }, {
      key: "unbuild",
      value: function unbuild() {
        if (!this.ready) {
          return;
        }

        this.ready = false;
        this.unbind();
        this.resetPreview();
        this.cropper.parentNode.removeChild(this.cropper);
        removeClass(this.element, CLASS_HIDDEN);
      }
    }, {
      key: "uncreate",
      value: function uncreate() {
        if (this.ready) {
          this.unbuild();
          this.ready = false;
          this.cropped = false;
        } else if (this.sizing) {
          this.sizingImage.onload = null;
          this.sizing = false;
          this.sized = false;
        } else if (this.reloading) {
          this.xhr.onabort = null;
          this.xhr.abort();
        } else if (this.image) {
          this.stop();
        }
      }
      /**
       * Get the no conflict cropper class.
       * @returns {Cropper} The cropper class.
       */

    }], [{
      key: "noConflict",
      value: function noConflict() {
        window.Cropper = AnotherCropper;
        return Cropper;
      }
      /**
       * Change the default options.
       * @param {Object} options - The new default options.
       */

    }, {
      key: "setDefaults",
      value: function setDefaults(options) {
        assign(DEFAULTS, isPlainObject(options) && options);
      }
    }]);

    return Cropper;
  }();

  assign(Cropper.prototype, render, preview, events, handlers, change, methods);

  return Cropper;

})));
